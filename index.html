<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ロストレガシー</title>
<style>
  :root{
    --hint-fill: rgba(56,189,248,.7);
    --card-aspect: 2 / 3;
    --card-back-image: url('lrura.jpg');
    --ruin-scale-my: 0.64;
    --ruin-scale-mini: 1.75;
    --card-large-title-size: 22px;
    --card-large-reading-size: 16px;
  }
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('lrtop.jpg'); }
  main.joined{ background-image:url('lrmain.jpg'); }

  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  .player-circle{
    position:relative;width:260px;height:260px;
    margin:20px auto 0;border-radius:50%;
    box-sizing:border-box;border:none;
  }
  .player-circle::before{content:'';}

  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    z-index:20;
  }
  .player-tag.me{
    background:#111;color:#fff;border-color:#111;
    transform: translate(-50%,-50%) translateY(-18px);
  }

  .player-fan{
    position:absolute;
    transform:translate(-50%,-50%);
    width:96px;
    height:62px;
    z-index:20;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    pointer-events:none;
  }
  /* ★ ③/④選択中はクリックできるようにする */
  .player-fan.pick-mode{ pointer-events:auto; }
  .player-fan.effect8-drop-target{
    pointer-events:auto;
  }
  .player-fan.effect8-drop-target::before{
    content:'';
    position:absolute;
    left:50%;
    top:50%;
    width:72px;
    height:72px;
    transform:translate(-50%, -50%);
    border-radius:50%;
    background:var(--hint-fill);
    z-index:1;
  }
  .player-fan.effect8-drop-active::before{
    background:var(--hint-fill);
    transform:translate(-50%, -50%) scale(1.06);
  }

  #myHandRow{ transform: translateY(30px); }
  #myHandRow.effect7-pick-target::before{
    content:'';
    position:absolute;
    inset:-10px -26px;
    border-radius:16px;
    border:none;
    background:var(--hint-fill);
    box-shadow:none;
    pointer-events:none;
  }
  #myHandRow.effect7-pick-active::before{
    background:var(--hint-fill);
    box-shadow:none;
    transform:scale(1.02);
  }

  .player-fan .fan-name{
    position:absolute;
    left:50%;
    top:0%;
    transform:translate(-50%, -21px);
    padding:3px 8px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.15);
    box-shadow:0 6px 14px rgba(0,0,0,.12);
    font-family: inherit;
    font-size: 12px;
    font-weight: 400;
    white-space:nowrap;
    color:#111;
    z-index:20;
    pointer-events:none;
  }

  /* ★センターエリア：下に下げて、横長四角に（遺跡など他は動かさない） */
  .center-area{
    position:absolute;
    left:50%;
    top:50%;
    --center-shift-y: 120px;
    transform:translate(-50%,-50%) translateY(var(--center-shift-y));
    width:176px; height:64px;
    border-radius:14px;
    background:transparent;
    border:none;
    box-shadow:none;
    display:grid; place-items:center;
    font-weight:900;
    font-size:11px;
    letter-spacing:.06em;
    user-select:none;
    z-index:5;
    color:transparent;
  }
  .center-area.drag-hint{
    border:none;
    background:var(--hint-fill);
    box-shadow:none;
    color:transparent;
  }
  .center-area.drag-hint::after{
    content:'';
  }
  .center-area.active-drop{
    border:none;
    background:var(--hint-fill);
    transform:translate(-50%,-50%) translateY(var(--center-shift-y)) scale(1.03);
    box-shadow:none;
  }

  /* 山札：遺跡位置に合わせて移動（JSで座標上書き） */
  .deck-pile{
    position:absolute;
    top:calc(50% + 14px);
    left:calc(50% - 108px);
    transform:translate(-50%,-50%);
    width:42px;height:62px;
    border-radius:10px;
    border:1px solid #bbb;
    background-color:#fff;
    background-image:var(--card-back-image);
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    box-shadow:0 6px 16px rgba(0,0,0,.18);
    z-index:7;
    isolation:isolate;
    user-select:none;
  }
  .deck-pile::after{
    content:'';
    position:absolute;
    left:50%;
    top:50%;
    width:82px;
    height:82px;
    border-radius:50%;
    background:var(--hint-fill);
    border:none;
    transform:translate(-50%,-50%) scale(.95);
    opacity:0;
    pointer-events:none;
    z-index:-1;
  }
  .deck-count{
    position:absolute;
    right:-8px; top:-8px;
    min-width:18px;height:18px;
    padding:0 5px;
    border-radius:999px;
    border:1px solid rgba(0,0,0,.15);
    background:rgba(255,255,255,.95);
    font-size:11px;
    font-weight:900;
    display:flex;align-items:center;justify-content:center;
    box-shadow:0 6px 14px rgba(0,0,0,.12);
  }
  .deck-pile.effect2-drop-target{
    box-shadow:0 6px 16px rgba(0,0,0,.18);
  }
  .deck-pile.effect2-drop-active{
    transform:translate(-50%,-50%) scale(1.06);
  }
  .deck-pile.effect2-drop-target::after{
    opacity:1;
  }
  .deck-pile.effect2-drop-active::after{
    opacity:1;
    transform:translate(-50%,-50%) scale(1.06);
  }

  /* 共通：裏カードの飛び（他プレイヤーにも見せる） */
  .draw-flyer, .back-flyer{
    position:fixed;
    width:42px;height:62px;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.2);
    background-color:#fff;
    background-image:var(--card-back-image);
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    box-shadow:0 18px 40px rgba(0,0,0,.28);
    pointer-events:none;
    z-index:9998;
    transform:translate(-50%,-50%);
    opacity:1;
  }

  /* 表（自分だけ見せてもOK用）：数字表示 */
  .front-flyer{
    position:fixed;
    width:60px;height:90px;
    border-radius:8px;
    border:2px solid rgba(37,99,235,.0);
    background:#fff;
    box-shadow:0 18px 40px rgba(0,0,0,.28);
    display:flex;align-items:center;justify-content:center;
    font-size:24px;font-weight:700;
    pointer-events:none;
    z-index:9999;
    transform:translate(-50%,-50%);
    opacity:1;
  }
  .front-flyer.face-flyer{
    display:block;
    overflow:hidden;
    border-color:rgba(0,0,0,.2);
    --card-title-size:10px;
    --card-reading-size:7px;
  }
  .front-flyer.ruin-reveal-flyer{
    transform-style:preserve-3d;
    backface-visibility:hidden;
  }

  @keyframes explorationReopen{
    0%{ transform:translate(-50%,0) rotate(var(--rot,0deg)) rotateY(0deg); }
    45%{ transform:translate(-50%,0) rotate(calc(var(--rot,0deg) + 90deg)) rotateY(180deg); }
    100%{ transform:translate(-50%,0) rotate(calc(var(--rot,0deg) + 360deg)) rotateY(360deg); }
  }
  .mini-card.exploration-reopen{
    animation: explorationReopen 720ms ease-in-out 1;
    transform-style:preserve-3d;
    backface-visibility:hidden;
  }

  .reshuffle-flyer{
    position:fixed;
    width:42px;height:62px;border-radius:10px;
    border:1px solid rgba(0,0,0,.18);
    background-color:#fff;
    background-image:var(--card-back-image);
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    box-shadow:0 18px 40px rgba(0,0,0,.28);
    pointer-events:none;
    z-index:9997;
    transform:translate(-50%,-50%);
    opacity:1;
  }

  @keyframes deckShake{
    0%{transform:translate(-50%,-50%) rotate(0deg);}
    25%{transform:translate(-50%,-50%) rotate(-6deg);}
    50%{transform:translate(-50%,-50%) rotate(6deg);}
    75%{transform:translate(-50%,-50%) rotate(-4deg);}
    100%{transform:translate(-50%,-50%) rotate(0deg);}
  }
  .deck-pile.shuffling{ animation: deckShake 520ms ease-in-out 1; }

  .turn-paused{ opacity:.92; filter:saturate(.95); }

  .mini-hand{
    position:relative;
    width:96px;
    height:56px;
    pointer-events:none;
    z-index:40;
  }
  .mini-card{
    position:absolute;
    left:50%;
    top:6px;
    width:24px;height:33px;
    border-radius:4px;border:1px solid #bbb;
    background-color:#fff;
    background-image:var(--card-back-image);
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
    pointer-events:none;
    --card-title-size:4.4px;
    --card-reading-size:3.6px;
  }

  /* ★③/④：扇カードが大小アニメ＆クリック可（使用者のみ） */
  @keyframes fanPickPulse{
    0%{ transform:translate(-50%,0) rotate(var(--rot,0deg)) scale(1); }
    45%{ transform:translate(-50%,0) rotate(var(--rot,0deg)) scale(1.44); }
    100%{ transform:translate(-50%,0) rotate(var(--rot,0deg)) scale(1); }
  }
  .mini-card.pickable{
    pointer-events:auto;
    cursor:pointer;
    animation: fanPickPulse 720ms ease-in-out infinite;
    outline:2px solid rgba(37,99,235,.0);
  }
  .mini-card.pickable:hover{
    outline:2px solid rgba(37,99,235,.55);
  }

  .played-row{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    display:flex;
    gap:4px;
    pointer-events:none;
    z-index:12;
  }
  .played-card{
    width:42px;
    aspect-ratio:var(--card-aspect);
    height:auto;
    border-radius:8px;
    border:1px solid rgba(0,0,0,.18);
    background:rgba(255,255,255,.96);
    box-shadow:0 8px 18px rgba(0,0,0,.16);
    transform-origin:center center;
    will-change:transform;
    position:relative;
    overflow:hidden;
    --card-title-size:8px;
    --card-reading-size:6px;
  }

  .card-face{
    position:absolute;
    inset:0;
    border-radius:inherit;
    background-color:#fff;
    background-image:var(--card-image);
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    display:block;
    pointer-events:none;
  }
  .card-overlay{
    position:absolute;
    inset:0;
    pointer-events:none;
  }
  .card-title{
    position:absolute;
    left:1%;
    top:1%;
    bottom:4%;
    writing-mode:vertical-rl;
    text-orientation:upright;
    white-space:pre-line;
    font-weight:800;
    font-size:var(--card-title-size, 12px);
    color:#111;
    text-shadow:0 1px 2px rgba(255,255,255,.75);
    letter-spacing:0.08em;
  }
  .card-title-number{
    font-size:calc(var(--card-title-size, 12px) + 2px);
  }
  .card-title-name{
    margin-block-start:0.25em;
  }

  .card-title.is-five,
  .card-title.is-five .card-title-number,
  .card-title.is-five .card-title-name{
    color:#f97316;
  }
  .card-decor-left{
    position:absolute;
    left:4%;
    bottom:4%;
    display:flex;
    gap:1.5px;
  }
  .card-decor-left span{
    width:1px;
    height:3px;
    border-radius:3px;
    background:#111;
    border:1px solid #111;
  }
  .card-decor-right{
    position:absolute;
    top:4%;
    right:var(--decor-right-offset, 4%);
    width:var(--decor-right-width, 65%);
    height:28%;
    border-radius:6px;
    border:none;
    background:transparent;
    display:flex;
    align-items:flex-start;
    justify-content:flex-start;
    text-align:left;
    padding:2px 3px;
    overflow:hidden;
  }
  .played-card{
    --decor-right-offset: -5%;
    --decor-right-width: 70%;
  }
  .my-card{
    --decor-right-offset: 0%;
    --decor-right-width: 70%;
  }
  .ruins-card{
    --decor-right-offset: -5%;
  }
  .mini-card.one-reveal-target,
  .mini-card.x-reveal-target,
  .mini-card.exploration-picked{
    --decor-right-offset: -5%;
  }
  .card-effect-text{
    display:block;
    width:100%;
    font-weight:700;
    color:#111;
    line-height:1.1;
    font-size:10px;
    white-space:pre-line;
  }
  .played-card .card-effect-text{
    font-weight:700;
    color:#111;
    line-height:1.1;
    font-size:10px;
  }

  .my-hand-wrapper{margin-top:16px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand-row{
    display:flex;
    align-items:center;
    justify-content:center;
    gap:8px;
    margin-top:6px;
    position:relative;
  }

  .my-hand{
    display:flex;
    justify-content:center;
    gap:8px;
    margin-top:0;
    min-height:100px;
  }

  .my-card{
    width:66px;
    aspect-ratio:var(--card-aspect);
    height:auto;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.18);
    background:#fff;
    box-shadow:0 4px 12px rgba(0,0,0,.15);
    user-select:none;
    touch-action:none;
    position:relative;
    overflow:hidden;
    --card-title-size:12px;
    --card-reading-size:9px;
  }
  .my-card .card-title{
    top:4%;
    bottom:auto;
  }

  .my-card.selected{
    outline:3px solid #2563eb;
    outline-offset:2px;
  }


  @keyframes myPulse {
    0%   { transform:scale(1); }
    50%  { transform:scale(1.14); }
    100% { transform:scale(1); }
  }
  .my-hand.is-playable .my-card{
    animation: myPulse 900ms ease-in-out infinite;
    cursor:grab;
  }
  .my-hand.is-playable .my-card:active{ cursor:grabbing; }
  .my-hand.is-playable:not(.effect2-pick):not(.effect6-pick):not(.effect7-place):not(.effect8-return) .my-card.no-play-pulse{
    animation:none;
    cursor:default;
  }

  /* ★②：手札選択（全カードが大小アニメ＆クリック可） */
  @keyframes pickPulse2 {
    0%   { transform:scale(1); }
    45%  { transform:scale(1.10); }
    100% { transform:scale(1); }
  }
  .my-hand.effect2-pick .my-card{
    animation: pickPulse2 760ms ease-in-out infinite;
    cursor:grab;
  }
  .my-hand.effect2-pick .my-card:hover{
    outline:2px solid rgba(37,99,235,.55);
    outline-offset:2px;
  }

  /* ⑥：選択フェーズ（遺跡へドラッグ） */
  @keyframes pickPulse {
    0%   { transform:scale(1); }
    40%  { transform:scale(1.08); }
    100% { transform:scale(1); }
  }
  .my-hand.effect6-pick .my-card{
    animation: pickPulse 760ms ease-in-out infinite;
    cursor:grab;
  }
  .my-hand.is-playable.effect6-pick .my-card{
    animation: pickPulse 760ms ease-in-out infinite;
    cursor:grab;
  }

  /* ★⑦：配置フェーズ（手札ドラッグ） */
  .my-hand.effect7-place .my-card{
    animation: pickPulse 760ms ease-in-out infinite;
    cursor:grab;
  }
  /* ★⑧：手札ドラッグ（手札全体が大小） */
  .my-hand.effect8-return .my-card{
    animation: pickPulse2 760ms ease-in-out infinite;
    cursor:grab;
  }

  @keyframes slideInRight {
    0%   { transform:translateX(22px); opacity:0; }
    100% { transform:translateX(0); opacity:1; }
  }
  .my-card.new-in{ animation: slideInRight 220ms ease both; }
  .my-hand.is-playable .my-card.new-in{
    animation: slideInRight 220ms ease both, myPulse 900ms ease-in-out infinite;
  }

  .drag-ghost{
    position:fixed;
    width:66px;
    aspect-ratio:var(--card-aspect);
    height:auto;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.2);
    background:#fff;
    box-shadow:0 18px 40px rgba(0,0,0,.28);
    pointer-events:none;
    z-index:9999;
    transform:translate(-50%,-50%);
    overflow:hidden;
    --card-title-size:12px;
    --card-reading-size:9px;
  }
  .drag-ghost.is-back{
    background-image:var(--card-back-image);
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }

  .my-card.drag-source-hidden{
    opacity:0 !important;
    pointer-events:none !important;
  }
  .ruins-card.drag-source-hidden{
    opacity:0 !important;
    pointer-events:none !important;
  }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
  .help-set{margin-bottom:14px;}
  .help-set-header{display:flex;align-items:center;gap:8px;margin-bottom:8px;}
  .help-set-toggle{
    border:1px solid #111;
    color:#111;
    font-weight:800;
    font-size:12px;
    padding:4px 10px;
    border-radius:999px;
    background:#fff;
    cursor:pointer;
  }
  .help-set-toggle.is-disabled{
    opacity:.5;
    border-style:dashed;
  }
  .help-card-grid{
    display:flex;
    flex-direction:column;
    gap:10px;
    transition:opacity .2s ease, filter .2s ease;
  }
  .help-card-grid.is-disabled{
    opacity:.35;
    filter:grayscale(1);
  }
  .help-card-row{
    display:flex;
    justify-content:flex-start;
    gap:8px;
    flex-wrap:nowrap;
  }
  .help-card{
    width:calc(66px * 1.2);
    aspect-ratio:var(--card-aspect);
    height:auto;
  }

  /* 遺跡エリア（2x3）：画面中心(=playerCircle中心)に固定。center-areaを動かしてもここは動かさない */
  .ruins-area{
    position:absolute;
    inset:0;
    pointer-events:none;
    z-index:6;
    --ru-gap-x:54px;
    --ru-gap-y:74px;
    --ru-half-y:37px;
    --ru-shift-y: 14px;
  }
  .ruins-area.drop-enabled{ pointer-events:auto; }

  .ruins-slot, .ruins-card{
    position:absolute;
    width:42px;height:62px;
    border-radius:10px;
    transform:translate(-50%,-50%);
    display:flex;align-items:center;justify-content:center;
  }
  .ruins-slot{
    border:none;
    background:transparent;
    box-shadow:none;
    pointer-events:auto;
  }
  .ruins-slot.next-target{
    border:none;
    box-shadow:none;
    background:var(--hint-fill);
  }
  .ruins-slot.hint-target{
    border:none;
    box-shadow:none;
    background:var(--hint-fill);
  }
  .ruins-slot.active-drop{
    border:none;
    background:var(--hint-fill);
    box-shadow:none;
    transform:translate(-50%,-50%) scale(1.06);
  }

  .ruins-card{
    border:1px solid rgba(0,0,0,.18);
    background-color:#fff;
    background-image:var(--card-back-image);
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    box-shadow:0 8px 18px rgba(0,0,0,.16);
    font-size:16px;font-weight:900;
    pointer-events:none;
    user-select:none;
    color:transparent;
    --card-title-size:7.6px;
    --card-reading-size:6.4px;
  }

  @keyframes ruinsPulse {
    0%   { transform:translate(-50%,-50%) scale(1); }
    45%  { transform:translate(-50%,-50%) scale(1.20); }
    100% { transform:translate(-50%,-50%) scale(1); }
  }
  .ruins-card.pickable{
    pointer-events:auto;
    cursor:grab;
    touch-action:none;
    animation: ruinsPulse 760ms ease-in-out infinite;
    outline:2px solid rgba(37,99,235,.0);
  }
  .ruins-card.pickable:hover{
    outline:2px solid rgba(37,99,235,.55);
  }

  /* 位置：2行×3列（中心＝playerCircle中心＝50%/50%） */
  .ruins-slot[data-i="0"], .ruins-card[data-i="0"]{ left:calc(50% - var(--ru-gap-x)); top:calc(50% - var(--ru-half-y) + var(--ru-shift-y)); }
  .ruins-slot[data-i="1"], .ruins-card[data-i="1"]{ left:50%;                           top:calc(50% - var(--ru-half-y) + var(--ru-shift-y)); }
  .ruins-slot[data-i="2"], .ruins-card[data-i="2"]{ left:calc(50% + var(--ru-gap-x)); top:calc(50% - var(--ru-half-y) + var(--ru-shift-y)); }
  .ruins-slot[data-i="3"], .ruins-card[data-i="3"]{ left:calc(50% - var(--ru-gap-x)); top:calc(50% + var(--ru-half-y) + var(--ru-shift-y)); }
  .ruins-slot[data-i="4"], .ruins-card[data-i="4"]{ left:50%;                           top:calc(50% + var(--ru-half-y) + var(--ru-shift-y)); }
  .ruins-slot[data-i="5"], .ruins-card[data-i="5"]{ left:calc(50% + var(--ru-gap-x)); top:calc(50% + var(--ru-half-y) + var(--ru-shift-y)); }

  /* ===== ③/④：矢印（点線）オーバーレイ ===== */
  .effect-arrow-overlay{
    position:fixed;
    inset:0;
    pointer-events:none;
    z-index:520;
  }
  .effect-arrow-overlay svg{ width:100%; height:100%; display:block; }
  .effect-arrow-overlay .line{
    stroke: rgba(17,17,17,.72);
    stroke-width: 2.2;
    stroke-dasharray: 6 6;
    fill:none;
  }
  .effect-arrow-overlay .head{
    fill: rgba(17,17,17,.72);
  }
  .effect-arrow-overlay .eye{
    font-size:18px;
    fill: rgba(17,17,17,.82);
    text-anchor:middle;
    dominant-baseline:middle;
  }

  /* ===== ③/④：見たカード拡大（使用者のみ） ===== */
  .peek-overlay{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center;
    z-index:900;
  }
  .peek-overlay.hidden{ display:none; }
  .peek-card{
    width:150px;
    aspect-ratio:var(--card-aspect);
    height:auto;
    border-radius:14px;
    border:2px solid rgba(255,255,255,.75);
    background:#fff;
    box-shadow:0 18px 44px rgba(0,0,0,.38);
    transform: rotate(-2deg);
    position:relative;
    overflow:hidden;
    --card-title-size:var(--card-large-title-size);
    --card-reading-size:var(--card-large-reading-size);
  }
  .zoom-overlay{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center;
    z-index:890;
  }
  .zoom-overlay.hidden{ display:none; }
  .zoom-card{
    width:170px;
    aspect-ratio:var(--card-aspect);
    height:auto;
    border-radius:16px;
    border:2px solid rgba(255,255,255,.85);
    background:#fff;
    box-shadow:0 18px 44px rgba(0,0,0,.38);
    transform: rotate(0deg);
    position:relative;
    overflow:hidden;
    --card-title-size:var(--card-large-title-size);
    --card-reading-size:var(--card-large-reading-size);
  }

  /* 画面下：水色ポップ（閉じてもいいですか／はい） */
  .confirm-pop{
    position:fixed;
    left:50%;
    bottom:12px;
    transform:translateX(-50%);
    background:#bfe8ff;
    border:1px solid rgba(0,0,0,.12);
    border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.20);
    padding:10px 12px;
    z-index:910;
    display:flex;
    align-items:center;
    gap:10px;
    min-width:280px;
    max-width: calc(100% - 24px);
  }
  .confirm-pop.hidden{ display:none; }
  .confirm-pop .msg{ font-size:13px; font-weight:800; color:#083344; }
  .confirm-pop .spacer{ flex:1 1 auto; }
  .confirm-pop .btn{ background:rgba(255,255,255,.85); border-color:rgba(0,0,0,.12); }
  .confirm-pop .btn.primary{ background:#111; border-color:#111; color:#fff; }

  /* ===== 全員：⑤スライド演出 ===== */
  .global-slide-card{
    position:fixed;
    top:50%;
    left:50%;
    transform:translate3d(-50%,-50%,0) scale(1);
    width:160px;
    aspect-ratio:var(--card-aspect);
    height:auto;
    border-radius:14px;
    background:#fff;
    border:2px solid rgba(0,0,0,.12);
    box-shadow:0 18px 44px rgba(0,0,0,.30);
    z-index:980;
    will-change:transform,left,opacity;
    pointer-events:none;
    overflow:hidden;
    --card-title-size:var(--card-large-title-size);
    --card-reading-size:var(--card-large-reading-size);
    opacity:0;
  }
  @keyframes fiveSlideMotion{
    0%{
      transform:translate3d(calc(-50% - 120vw), -50%, 0) scale(0.72);
      opacity:0;
    }
    25%{
      transform:translate3d(-50%, -50%, 0) scale(1.12);
      opacity:1;
    }
    55%{
      transform:translate3d(-50%, -50%, 0) scale(1.08);
      opacity:1;
    }
    100%{
      transform:translate3d(calc(-50% + 120vw), -50%, 0) scale(0.9);
      opacity:0;
    }
  }

  /* ===== 全員：✕拡大 ===== */
  .global-x-backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center;
    z-index:975;
    pointer-events:none;
  }
  .global-x-backdrop.hidden{ display:none; }
  .global-x-card{
    width:170px;
    aspect-ratio:var(--card-aspect);
    height:auto;
    border-radius:16px;
    background:#fff;
    border:2px solid rgba(255,255,255,.78);
    box-shadow:0 22px 56px rgba(0,0,0,.42);
    opacity:0;
    transform:translateY(38vh) scale(0.95);
    transform-origin:center bottom;
    position:relative;
    overflow:hidden;
    --card-title-size:var(--card-large-title-size);
    --card-reading-size:var(--card-large-reading-size);
  }
  @keyframes xShake{
    0%{ transform:translateY(0) scale(1.06) rotate(0deg); }
    20%{ transform:translateY(0) scale(1.06) rotate(4deg); }
    40%{ transform:translateY(0) scale(1.06) rotate(-4deg); }
    60%{ transform:translateY(0) scale(1.06) rotate(3deg); }
    80%{ transform:translateY(0) scale(1.06) rotate(-3deg); }
    100%{ transform:translateY(0) scale(1.06) rotate(0deg); }
  }
  .global-x-card.x-shake{
    animation: xShake 360ms ease-in-out 1;
  }
  @keyframes xFallBack{
    0%{ transform:translateY(0) scale(1.05) rotateX(0deg); opacity:1; }
    100%{ transform:translateY(36px) scale(0.92) rotateX(72deg); opacity:0; }
  }
  .global-x-card.x-fall-back{
    animation: xFallBack 820ms ease-in forwards;
  }

  /* ===== 全員：1拡大 ===== */
  .global-one-backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center;
    z-index:974;
    pointer-events:none;
  }
  .global-one-backdrop.hidden{ display:none; }
  @keyframes onePulse{
    0%{ transform:scale(.6); opacity:.2; }
    45%{ transform:scale(1.08); opacity:1; }
    70%{ transform:scale(.96); opacity:1; }
    100%{ transform:scale(1); opacity:.95; }
  }
  .global-one-card{
    width:170px;
    aspect-ratio:var(--card-aspect);
    height:auto;
    border-radius:16px;
    background:#fff;
    border:2px solid rgba(255,255,255,.8);
    box-shadow:0 22px 56px rgba(0,0,0,.42);
    animation: onePulse 1500ms ease-in-out 1;
    position:relative;
    overflow:hidden;
    --card-title-size:var(--card-large-title-size);
    --card-reading-size:var(--card-large-reading-size);
  }

  .player-fan.one-reveal{
    transform:translate(-50%,-50%);
    z-index:70;
  }
  .my-hand-row.one-reveal{
    transform:translateY(30px);
    z-index:70;
  }
  .mini-card.one-reveal-front{
    background:#fff;
    color:#111;
    font-weight:900;
    font-size:12px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .mini-card.one-reveal-target{
    transform:translate(-50%,0) rotate(var(--rot,0deg)) scale(var(--ruin-scale-mini)) !important;
    z-index:92;
  }
  .my-card.one-reveal-target{
    transform:scale(var(--ruin-scale-my));
    z-index:92;
  }
  .player-fan.x-reveal{
    transform:translate(-50%,-50%);
    z-index:70;
    transition:transform 240ms ease;
  }
  .my-hand-row.x-reveal{
    transform:translateY(30px);
    z-index:70;
    transition:transform 240ms ease;
  }
  .mini-card.x-reveal-front{
    background:#fff;
    color:#111;
    font-weight:900;
    font-size:12px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .mini-card.x-reveal-target{
    transform:translate(-50%,0) rotate(var(--rot,0deg)) scale(var(--ruin-scale-mini)) !important;
    z-index:92;
  }
  .my-card.x-reveal-target{
    transform:scale(var(--ruin-scale-my));
    z-index:92;
  }

  /* ゲーム終了表示 */
  .gameover-pop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.52);
    display:flex; align-items:center; justify-content:center;
    z-index:990;
  }
  .gameover-pop.hidden{ display:none; }
  .gameover-pop.found5 .gameover-box{
    background:#000;
    color:#fff;
    border-color:rgba(255,255,255,.15);
    width:auto;
    max-width:calc(100% - 28px);
  }
  .gameover-pop.found5 .ttl{ display:none; }
  .gameover-pop.found5 .txt{
    white-space:nowrap;
    font-size:17px;
    line-height:1.4;
    font-weight:800;
  }
  .gameover-pop.found5{ pointer-events:none; }
  .gameover-box{
    background:#fff;
    border-radius:16px;
    border:1px solid rgba(0,0,0,.12);
    box-shadow:0 20px 60px rgba(0,0,0,.35);
    padding:16px 18px;
    width:min(360px, calc(100% - 28px));
  }
  .gameover-box .ttl{ font-weight:1000; font-size:16px; margin-bottom:6px; }
  .gameover-box .txt{ font-size:13px; line-height:1.55; opacity:.92; }

  .center-notice{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%, -50%);
    background:rgba(0,0,0,.88);
    color:#fff;
    padding:14px 18px;
    border-radius:14px;
    font-size:16px;
    font-weight:800;
    letter-spacing:.05em;
    z-index:996;
    box-shadow:0 18px 40px rgba(0,0,0,.4);
    white-space:nowrap;
    pointer-events:none;
  }
  .center-notice.hidden{ display:none; }

  .exploration-pop{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%, -50%);
    background:rgba(0,0,0,.88);
    color:#fff;
    padding:14px 18px;
    border-radius:14px;
    font-size:16px;
    font-weight:800;
    letter-spacing:.08em;
    z-index:995;
    box-shadow:0 18px 40px rgba(0,0,0,.4);
    pointer-events:none;
  }
  .exploration-pop.hidden{ display:none; }

  .player-fan.exploration-reveal{
    transform:translate(-50%,-50%);
    z-index:60;
  }
  .my-hand-row.exploration-reveal{
    transform:translateY(30px);
    z-index:60;
  }
  .mini-card.exploration-front,
  .ruins-card.exploration-front{
    background:#fff;
    color:#111;
    font-weight:900;
    font-size:14px;
  }
  .mini-card.exploration-front{
    width:42px;
    height:62px;
    top:0;
    border-radius:10px;
    --card-title-size:7.6px;
    --card-reading-size:6.4px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .ruins-card.exploration-front{
    color:#111;
  }

  @keyframes explorationFlip{
    0%{ transform:rotateY(0deg); color:#111; background:#fff; }
    45%{ transform:rotateY(90deg); color:transparent; background-image:var(--card-back-image); background-color:#fff; background-size:cover; background-position:center; }
    55%{ transform:rotateY(90deg); color:transparent; background-image:var(--card-back-image); }
    100%{ transform:rotateY(0deg); color:#111; background:#fff; }
  }
  .my-hand-row.exploration-flip .my-card{
    animation: explorationFlip 900ms ease-in-out 1;
    transform-style:preserve-3d;
    backface-visibility:hidden;
  }

  @keyframes explorationShake{
    0%{ transform:translate(-50%,-50%) scale(1.4) rotate(0deg); }
    20%{ transform:translate(-50%,-50%) scale(1.4) rotate(4deg); }
    40%{ transform:translate(-50%,-50%) scale(1.4) rotate(-4deg); }
    60%{ transform:translate(-50%,-50%) scale(1.4) rotate(3deg); }
    80%{ transform:translate(-50%,-50%) scale(1.4) rotate(-3deg); }
    100%{ transform:translate(-50%,-50%) scale(1.4) rotate(0deg); }
  }
  @keyframes explorationShakeMe{
    0%{ transform:translateY(30px) scale(1.4) rotate(0deg); }
    20%{ transform:translateY(30px) scale(1.4) rotate(4deg); }
    40%{ transform:translateY(30px) scale(1.4) rotate(-4deg); }
    60%{ transform:translateY(30px) scale(1.4) rotate(3deg); }
    80%{ transform:translateY(30px) scale(1.4) rotate(-3deg); }
    100%{ transform:translateY(30px) scale(1.4) rotate(0deg); }
  }
  .player-fan.exploration-shake{ animation: explorationShake 520ms ease-in-out infinite; }
  .my-hand-row.exploration-shake{ animation: explorationShakeMe 520ms ease-in-out infinite; }

  @keyframes explorationTieShake{
    0%{ transform:translate(-50%,-50%) scale(1.4) rotate(0deg); }
    25%{ transform:translate(-50%,-50%) scale(1.4) rotate(3deg); }
    50%{ transform:translate(-50%,-50%) scale(1.4) rotate(-3deg); }
    75%{ transform:translate(-50%,-50%) scale(1.4) rotate(2deg); }
    100%{ transform:translate(-50%,-50%) scale(1.4) rotate(0deg); }
  }
  @keyframes explorationTieShakeMe{
    0%{ transform:translateY(30px) scale(1.4) rotate(0deg); }
    25%{ transform:translateY(30px) scale(1.4) rotate(3deg); }
    50%{ transform:translateY(30px) scale(1.4) rotate(-3deg); }
    75%{ transform:translateY(30px) scale(1.4) rotate(2deg); }
    100%{ transform:translateY(30px) scale(1.4) rotate(0deg); }
  }
  .player-fan.exploration-tie-shake{ animation: explorationTieShake 240ms ease-in-out 2; }
  .my-hand-row.exploration-tie-shake{ animation: explorationTieShakeMe 240ms ease-in-out 2; }

  .mini-card.exploration-pickable{
    pointer-events:auto;
    cursor:pointer;
    animation: fanPickPulse 720ms ease-in-out infinite;
    outline:2px solid rgba(37,99,235,.0);
  }
  .mini-card.exploration-front.exploration-pickable{
    animation:none;
    pointer-events:none;
  }
  .mini-card.exploration-pickable:hover{
    outline:2px solid rgba(37,99,235,.55);
  }
  .mini-card.exploration-picked{
    transform:translate(-50%,0) rotate(var(--rot,0deg)) scale(1.4) !important;
    z-index:90;
  }
  .ruins-card.exploration-pickable{
    pointer-events:auto;
    cursor:pointer;
    animation: ruinsPulse 760ms ease-in-out infinite;
    outline:2px solid rgba(37,99,235,.0);
  }
  .ruins-card.exploration-front.exploration-pickable{
    animation:none;
    pointer-events:none;
  }
  .ruins-card.exploration-pickable:hover{
    outline:2px solid rgba(37,99,235,.55);
  }
  .ruins-card.exploration-picked{
    transform:translate(-50%,-50%) scale(1.4);
    z-index:90;
  }

  .exploration-center-card{
    position:fixed;
    left:50%;
    top:50%;
    width:140px;
    height:210px;
    border-radius:14px;
    border:2px solid rgba(37,99,235,.15);
    background:#fff;
    box-shadow:0 22px 56px rgba(0,0,0,.35);
    display:block;
    --card-title-size:var(--card-large-title-size);
    --card-reading-size:var(--card-large-reading-size);
    transform:translate(-50%,-50%) scale(1.12);
    opacity:0;
    z-index:998;
  }
  @keyframes explorationFall{
    0%{ transform:translate(-50%,-50%) scale(1.12) rotate(0deg); opacity:1; }
    20%{ transform:translate(-50%,-50%) scale(1.12) rotate(-8deg); opacity:1; }
    100%{ transform:translate(-50%, calc(-50% + 220px)) scale(0.92) rotate(14deg); opacity:0; }
  }
  .exploration-center-card.drop{
    animation: explorationFall 720ms ease-in forwards;
  }
</style>
</head>
<body>

<header>
  <h1>ロストレガシー</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">
      <div id="deckPile" class="deck-pile" title="山札">
        <div id="deckCount" class="deck-count">0</div>
      </div>

      <div id="centerArea" class="center-area"></div>
    </div>

    <div class="my-hand-wrapper">
    <div class="my-hand-row" id="myHandRow">
        <div id="myHand" class="my-hand"></div>
      </div>
    </div>
  </div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>
<button id="helpBtn" class="help-btn" title="カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">山札カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で <b>手札(各1枚)</b> を配布し、<br>
    さらに <b>最初のプレイヤーに1枚ドロー</b> します。<br>
    ※「自分の手番」かつ「手札が2枚」の時だけ、パルス＆ドラッグ可。<br>
    ※ドロー演出は <b>全員の画面</b> に出ます。<br>
    ★ 今回：<b>ドロー演出が終わってから</b> 手札が増えます（重複見え防止）。<br>
    ★ 追加：山札0枚で <b>そのターン終了</b>＆画面中央に「探索フェイス」表示（シャッフルなし）。<br>
    ★ ②：<b>追加で1枚ドロー(全員に裏で移動可視)</b> → <b>手札全て大小</b> → <b>1枚ドラッグ</b> → <b>山札の一番上へ戻す(全員に裏で移動可視)</b><br>
    ★ ③：<b>他プレイヤー扇カード大小</b> → <b>1枚選んで使用者だけ拡大</b> → <b>他全員は使用者→対象へ点線矢印</b> → <b>下ポップ「閉じてもいいですか」→はいで次ターン</b><br>
    ★ ④：<b>他プレイヤー扇カード大小</b> → <b>1枚選んで使用者だけ拡大</b> → <b>他全員は使用者→対象へ点線矢印</b> → <b>下ポップ→はいで次ターン</b>（✕なら演出＆✕所有者脱落）<br>
    ★ ⑥：<b>追加で1枚ドロー</b> → <b>手札大小</b> → <b>1枚をドラッグして遺跡(2x3順番)へ配置</b><br>
    ★ ⑦：<b>遺跡カード全て大小</b> → <b>1枚ドラッグで手札へ</b> → <b>手札大小＆ドラッグ</b> → <b>空いた遺跡スロットへ配置</b><br>
    ★ 追加：⑦の「遺跡→手札」「手札→遺跡」移動アニメを <b>他プレイヤーの画面</b> にも表示
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<!-- ★③/④：使用者だけ「見たカード」拡大 -->
<div id="peekOverlay" class="peek-overlay hidden">
  <div id="peekCard" class="peek-card">?</div>
</div>
<div id="zoomOverlay" class="zoom-overlay hidden" aria-hidden="true">
  <div id="zoomCard" class="zoom-card"></div>
</div>

<!-- ★③/④：水色ポップ -->
<div id="confirmPop" class="confirm-pop hidden">
  <div class="msg" id="confirmMsg">閉じてもいいですか</div>
  <div class="spacer"></div>
  <button class="btn primary" id="btnConfirmYes">はい</button>
</div>

<!-- ★全員：✕拡大＋揺れ -->
<div id="globalXBackdrop" class="global-x-backdrop hidden">
  <div class="global-x-card" id="globalXCard">✕</div>
</div>

<!-- ★全員：1拡大 -->
<div id="globalOneBackdrop" class="global-one-backdrop hidden">
  <div class="global-one-card" id="globalOneCard">1</div>
</div>

<!-- ★全員：ゲーム終了 -->
<div id="gameOverPop" class="gameover-pop hidden">
  <div class="gameover-box">
    <div class="ttl">ゲーム終了</div>
    <div class="txt" id="gameOverTxt">終了しました。</div>
  </div>
</div>

<div id="centerNotice" class="center-notice hidden"></div>

<div id="explorationPop" class="exploration-pop hidden">探索フェイス</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove, runTransaction
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const DRAW_COMMIT_DELAY_MS = 620;
const RESHUFFLE_ANIM_MS = 980;
const RUIN_MOVE_ANIM_MS = 760;
const RUIN_TAKE_ANIM_MS = 760;
const FIVE_SLIDE_IN_MS = 600;
const FIVE_SLIDE_HOLD_MS = 1200;
const FIVE_SLIDE_OUT_MS = 520;
const FIVE_SLIDE_TOTAL_MS = FIVE_SLIDE_IN_MS + 120 + FIVE_SLIDE_HOLD_MS + FIVE_SLIDE_OUT_MS;
const FIVE_ARROW_DELAY_MS = 1200;
const LAST_SURVIVOR_DELAY_MS = 1200;
const XRAY_MINI_DELAY_MS = 1200;
const ONE_REVEAL_DELAY_MS = 1200;

const CARD_META = {
  "1": { name: "宿命の少女", reading: "しゅくめい\u3000しょうじょ" },
  "2": { name: "将軍", reading: "しょうぐん" },
  "3": { name: "女盗賊", reading: "おんなとうぞく" },
  "4": { name: "剣士", reading: "けんせい" },
  "5": { name: "星を渡る船", reading: "ロストレガシー" },
  "6": { name: "古地図", reading: "ふるちず" },
  "7": { name: "調査", reading: "ちょうさ" },
  "8": { name: "襲撃", reading: "しゅうげき" },
  "x": { name: "待ち伏せ", reading: "ま\u3000ぶ" },
};

function normalizeCardValue(value){
  if (value === null || value === undefined) return '';
  const v = String(value);
  if (v === '✕' || v === '×') return 'x';
  return v;
}

function getCardMeta(value){
  const key = normalizeCardValue(value);
  return CARD_META[key] || { name: '', reading: '' };
}

function getCardEffectText(value){
  const key = normalizeCardValue(value);
  switch (key){
    case '1':
      return '手札の1が見られた時、あなたは脱落。';
    case '2':
      return '山札の一番上のカードと手札を交換できる。';
    case '3':
      return '他プレイヤーの手札を見て、《失われた遺産》なら勝利。';
    case '4':
      return '他プレイヤーの手札を見て、×ならそのカードを捨て札にさせる。';
    case '5':
      return 'このカードはプレイできない。';
    case '6':
      return '山札から1枚引いて、好きなカードを遺跡に置く。';
    case '7':
      return '遺跡から1枚を取って、手札と交換できる。';
    case '8':
      return '他プレイヤーの手札を見て、手札と交換できる。';
    case 'x':
      return '手札の✕が見られた時、これを捨て札に置き、見たプレイヤーの手札を奪う。';
    default:
      return '';
  }
}

function getCardDecorCount(value){
  const key = normalizeCardValue(value);
  switch (key){
    case '6':
      return 2;
    case '7':
    case '8':
    case 'x':
      return 3;
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
      return 1;
    default:
      return 0;
  }
}

function fitTextToBox(container, textEl, { minSize = 4, maxSize = 10 } = {}){
  const text = textEl.textContent || '';
  if (!text) return false;

  const rect = container.getBoundingClientRect();
  const baseWidth = container.offsetWidth || rect.width;
  const baseHeight = container.offsetHeight || rect.height;
  if (!rect.width || !rect.height || !baseWidth || !baseHeight){
    const approx = Math.max(minSize, Math.min(maxSize, Math.floor(42 / Math.max(1, text.length))));
    textEl.style.fontSize = `${approx}px`;
    return false;
  }

  const scaleX = rect.width / baseWidth;
  const scaleY = rect.height / baseHeight;
  const scaledWidth = rect.width;
  const scaledHeight = rect.height;

  const maxByHeight = Math.floor((scaledHeight * 0.6) / Math.max(0.1, scaleY));
  const maxByWidth = Math.floor((scaledWidth * 0.28) / Math.max(0.1, scaleX));
  let size = Math.min(maxSize, Math.max(minSize, maxByHeight, maxByWidth));

  for (let i = 0; i < 26; i++){
    textEl.style.fontSize = `${size}px`;
    const scrollWidth = textEl.scrollWidth * scaleX;
    const scrollHeight = textEl.scrollHeight * scaleY;
    if (scrollWidth <= scaledWidth && scrollHeight <= scaledHeight) break;
    size = Math.max(minSize, size - 0.5);
    if (size <= minSize) break;
  }
  return true;
}

function attachDecorRightFitter(cardEl, decorRight, effectText, fitOptions){
  const MAX_RETRY = 4;
  let rafId = null;
  let retry = 0;

  const runFit = () => {
    rafId = null;
    const measured = fitTextToBox(decorRight, effectText, fitOptions);
    if (!measured && retry < MAX_RETRY){
      retry += 1;
      rafId = requestAnimationFrame(runFit);
    }
  };

  const schedule = () => {
    retry = 0;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(runFit);
  };

  schedule();

  if (decorRight._fitObserver || !('ResizeObserver' in window)){
    return;
  }

  const ro = new ResizeObserver(schedule);
  ro.observe(decorRight);
  ro.observe(cardEl);

  const mo = new MutationObserver((entries) => {
    if (entries.some((entry) => entry.type === 'attributes')) schedule();
  });
  mo.observe(cardEl, { attributes:true, attributeFilter:['class', 'style'] });

  decorRight._fitObserver = { ro, mo };
}

function setCardFace(el, value){
  if (!el) return;
  const key = normalizeCardValue(value);
  el.dataset.value = key;
  el.innerHTML = '';
  if (!key){
    el.style.removeProperty('--card-image');
    return;
  }

  const meta = getCardMeta(key);
  const displayNumber = key === 'x' ? '×' : key;
  el.style.setProperty('--card-image', `url('lr${key}.jpg')`);

  const face = document.createElement('div');
  face.className = 'card-face';

  const overlay = document.createElement('div');
  overlay.className = 'card-overlay';

  const title = document.createElement('div');
  title.className = 'card-title';
  if (key === '5') title.classList.add('is-five');
  const numberEl = document.createElement('span');
  numberEl.className = 'card-title-number';
  numberEl.textContent = displayNumber;

  const nameEl = document.createElement('span');
  nameEl.className = 'card-title-name';
  nameEl.textContent = meta.name;

  title.append(numberEl, nameEl);



  const decorLeft = document.createElement('div');
  decorLeft.className = 'card-decor-left';
  const decorCount = getCardDecorCount(key);
  for (let i = 0; i < decorCount; i++){
    const bar = document.createElement('span');
    decorLeft.appendChild(bar);
  }

  const decorRight = document.createElement('div');
  decorRight.className = 'card-decor-right';
  const effectText = document.createElement('span');
  effectText.className = 'card-effect-text';
  effectText.textContent = getCardEffectText(key);
  decorRight.appendChild(effectText);
  const isLargeFace = el.classList.contains('peek-card')
    || el.classList.contains('zoom-card')
    || el.classList.contains('exploration-center-card')
    || el.classList.contains('global-x-card')
    || el.classList.contains('global-one-card')
    || el.classList.contains('global-slide-card');
  const isPlayedFace = el.classList.contains('played-card');
  const isCompactFace = el.classList.contains('ruins-card') || el.classList.contains('mini-card');
  const isMiniZoom = el.classList.contains('one-reveal-target')
    || el.classList.contains('x-reveal-target')
    || el.classList.contains('exploration-picked');
  const fitOptions = isPlayedFace
    ? { minSize: 3, maxSize: 9 }
    : (isLargeFace ? { minSize: 12, maxSize: 16 }
      : (isMiniZoom ? { minSize: 4, maxSize: 9 }
        : (isCompactFace ? { minSize: 3, maxSize: 8 } : { minSize: 4, maxSize: 10 })));
  attachDecorRightFitter(el, decorRight, effectText, fitOptions);

  overlay.appendChild(title);
  overlay.appendChild(decorLeft);
  overlay.appendChild(decorRight);
  face.appendChild(overlay);
  el.appendChild(face);
}

function clearCardFaceVisual(el){
  if (!el) return;
  el.innerHTML = '';
  el.style.removeProperty('--card-image');
}

function createFaceFlyer(cardValue){
  const flyer = document.createElement('div');
  flyer.className = 'front-flyer face-flyer';
  setCardFace(flyer, cardValue);
  return flyer;
}

function createBackGhost(){
  const ghost = document.createElement('div');
  ghost.className = 'drag-ghost is-back';
  return ghost;
}

/* ★遺跡を下げた分（CSSと合わせる） */
const RUINS_SHIFT_Y = 14;
const RUINS_GAP_X = 54;
const RUINS_GAP_Y = 74;

const EFFECT4_X_GLOBAL_MS = 1600;
const EFFECT4_X_AFTER_CLOSE_DELAY_MS = 1500;
const EFFECT4_X_HAND_REVEAL_MS = 1200;
const EFFECT4_X_HAND_RETURN_MS = 300;

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  played: {},
  room: {},
  deck: [],
  ruins: [],

  effect2: null,
  effect3: null,
  effect4: null,
  effect6: null,
  effect7: null,
  effect8: null,

  eliminated: {},     // ★脱落者
  gameOver: null,     // ★ゲーム終了

  turn: { currentPlayerId:null, turnSeq:0, drawn:false, paused:false },
  turnPlayerId: null,
  isMyTurn: false,
  isPlayable: false,
};

const ui = {
  effect2Selecting: false,
  effect2SelectedIndex: null,
  effect2DropPending: false,

  effect3Selecting: false,
  effect4Selecting: false,

  effect6Selecting: false,
  selectedIndex: null,

  effect7Picking: false,
  effect7Placing: false,
  effect7TargetSlot: null,
  effect7PickedValue: null,

  effect8Selecting: false,
  effect8Returning: false,
  effect8TargetPlayerId: null,

  confirmAction: null,
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const deckPile = document.getElementById('deckPile');
const deckCountEl = document.getElementById('deckCount');
const centerArea = document.getElementById('centerArea');

const myHandRow = document.getElementById('myHandRow');
const myHandEl = document.getElementById('myHand');
const myIdentityEl = document.getElementById('myIdentity');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const peekOverlay = document.getElementById('peekOverlay');
const peekCardEl  = document.getElementById('peekCard');
const zoomOverlay = document.getElementById('zoomOverlay');
const zoomCardEl = document.getElementById('zoomCard');

const confirmPop = document.getElementById('confirmPop');
const confirmMsg = document.getElementById('confirmMsg');
const btnConfirmYes = document.getElementById('btnConfirmYes');

const globalXBackdrop = document.getElementById('globalXBackdrop');
const globalOneBackdrop = document.getElementById('globalOneBackdrop');

const gameOverPop = document.getElementById('gameOverPop');
const gameOverTxt = document.getElementById('gameOverTxt');
const centerNotice = document.getElementById('centerNotice');
const explorationPop = document.getElementById('explorationPop');

let effectArrowOverlayEl = null;
function getEffectArrowOverlay(){
  if (effectArrowOverlayEl) return effectArrowOverlayEl;
  effectArrowOverlayEl = document.createElement('div');
  effectArrowOverlayEl.className = 'effect-arrow-overlay';
  document.body.appendChild(effectArrowOverlayEl);
  return effectArrowOverlayEl;
}

const DECK_SETS = [
  {
    id: 'starship',
    name: '星を渡る船',
    cards: [1,2,3,4,5,6,6,7,8,'x','x','x'],
    helpRows: [
      [1,2,3,4,5],
      [6,7,8,'x'],
    ],
  },
];
const deckSetState = Object.fromEntries(DECK_SETS.map((set) => [set.id, true]));

function renderHelpList(){
  helpBody.innerHTML = '';
  DECK_SETS.forEach((set) => {
    const section = document.createElement('div');
    section.className = 'help-set';

    const header = document.createElement('div');
    header.className = 'help-set-header';

    const toggle = document.createElement('button');
    toggle.type = 'button';
    toggle.className = 'help-set-toggle';
    toggle.textContent = set.name;

    const enabled = !!deckSetState[set.id];
    toggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
    if (!enabled) toggle.classList.add('is-disabled');

    header.appendChild(toggle);
    section.appendChild(header);

    const grid = document.createElement('div');
    grid.className = 'help-card-grid';
    if (!enabled) grid.classList.add('is-disabled');

    set.helpRows.forEach((rowCards) => {
      const row = document.createElement('div');
      row.className = 'help-card-row';
      rowCards.forEach((value) => {
        const card = document.createElement('div');
        card.className = 'my-card help-card';
        setCardFace(card, value);
        row.appendChild(card);
      });
      grid.appendChild(row);
    });

    toggle.addEventListener('click', () => {
      deckSetState[set.id] = !deckSetState[set.id];
      const isEnabled = deckSetState[set.id];
      toggle.setAttribute('aria-pressed', isEnabled ? 'true' : 'false');
      toggle.classList.toggle('is-disabled', !isEnabled);
      grid.classList.toggle('is-disabled', !isEnabled);
    });

    section.appendChild(grid);
    helpBody.appendChild(section);
  });
}
function openHelp(){ renderHelpList(); helpBackdrop.classList.remove('hidden'); }
function closeHelp(){ helpBackdrop.classList.add('hidden'); }
helpBtn.addEventListener('click', () => { if (joinBox.classList.contains('hidden')) openHelp(); });
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => { if (e.target === helpBackdrop) closeHelp(); });

btnConfirmYes.addEventListener('click', async () => {
  if (typeof ui.confirmAction === 'function'){
    const fn = ui.confirmAction;
    ui.confirmAction = null;
    hideConfirmPop();
    await fn();
  }
});

function showConfirmPop(text, onYes){
  confirmMsg.textContent = text || '閉じてもいいですか';
  ui.confirmAction = onYes;
  confirmPop.classList.remove('hidden');
}
function hideConfirmPop(){
  confirmPop.classList.add('hidden');
  ui.confirmAction = null;
}

function showPeekCard(value){
  setCardFace(peekCardEl, value);
  peekOverlay.classList.remove('hidden');
}
function hidePeekCard(){
  peekOverlay.classList.add('hidden');
}

function showZoomCard(value){
  if (!zoomOverlay || !zoomCardEl) return;
  setCardFace(zoomCardEl, value);
  zoomOverlay.classList.remove('hidden');
}
function hideZoomCard(){
  if (!zoomOverlay) return;
  zoomOverlay.classList.add('hidden');
}

if (zoomOverlay){
  zoomOverlay.addEventListener('click', (e) => {
    if (e.target === zoomOverlay) hideZoomCard();
  });
}

function showGameOver(text){
  gameOverTxt.textContent = text || 'ゲーム終了';
  gameOverPop.classList.remove('hidden');
}
function hideGameOver(){
  gameOverPop.classList.add('hidden');
}

function showCenterNotice(text){
  if (!centerNotice) return;
  centerNotice.textContent = text || '';
  centerNotice.classList.toggle('hidden', !text);
}
function hideCenterNotice(){
  if (!centerNotice) return;
  centerNotice.classList.add('hidden');
}

async function showExplorationFace(){
  explorationPop.classList.remove('hidden');
  await sleep(1000);
  explorationPop.classList.add('hidden');
}

let explorationSequenceActive = false;
let explorationSelectionCleanup = null;
let explorationSelectionTimer = null;
let explorationStopRequested = false;
const explorationRevealState = {
  players: new Map(),
  ruins: new Map(),
};

function markExplorationRevealedHand(playerId, cardIndex, value){
  if (!playerId || !Number.isFinite(Number(cardIndex))) return;
  const existing = explorationRevealState.players.get(playerId) || new Map();
  existing.set(Number(cardIndex), value ?? null);
  explorationRevealState.players.set(playerId, existing);
}

function clearExplorationRevealedHand(playerId){
  if (!playerId) return;
  explorationRevealState.players.delete(playerId);
}

function clearExplorationRevealedHandIndex(playerId, cardIndex){
  if (!playerId || !Number.isFinite(Number(cardIndex))) return;
  const existing = explorationRevealState.players.get(playerId);
  if (!existing) return;
  existing.delete(Number(cardIndex));
  if (!existing.size){
    explorationRevealState.players.delete(playerId);
  }
}

function markExplorationRevealedRuin(ruinIndex, value){
  if (!Number.isFinite(Number(ruinIndex))) return;
  explorationRevealState.ruins.set(Number(ruinIndex), value ?? null);
}

function clearExplorationRevealedRuin(ruinIndex){
  if (!Number.isFinite(Number(ruinIndex))) return;
  explorationRevealState.ruins.delete(Number(ruinIndex));
}

function resetExplorationState({ render = true } = {}){
  explorationSequenceActive = false;
  explorationStopRequested = false;
  cleanupExplorationSelection();
  explorationRevealState.players.clear();
  explorationRevealState.ruins.clear();
  if (myHandRow){
    myHandRow.classList.remove('exploration-reveal', 'exploration-flip', 'exploration-shake', 'exploration-tie-shake');
  }
  if (playerCircle){
    playerCircle.querySelectorAll('.player-fan').forEach((fan) => {
      fan.classList.remove('exploration-reveal', 'exploration-shake', 'exploration-tie-shake');
    });
  }
  if (render) renderHands();
}
let tempArrowConfig = null;
let lastSurvivorTimer = null;
let pendingXRevealTarget = null;
let pendingOneRevealTarget = null;

function getCardRank(value){
  if (value === null || value === undefined) return null;
  const v = String(value);
  if (v === 'x' || v === '✕') return 99;
  const n = Number(v);
  return Number.isFinite(n) ? n : 99;
}

function getExplorationGroups(){
  const groups = new Map();
  latestPlayers.forEach((p) => {
    if (state.eliminated?.[p.id]) return;
    const hand = state.hands?.[p.id];
    const cards = Array.isArray(hand?.cards) ? hand.cards : [];
    if (!cards.length) return;
    const ranks = cards.map(getCardRank).filter((v) => v !== null);
    if (!ranks.length) return;
    const minRank = Math.min(...ranks);
    if (!groups.has(minRank)) groups.set(minRank, []);
    groups.get(minRank).push(p.id);
  });

  return [...groups.entries()]
    .sort((a,b) => a[0] - b[0])
    .map(([rank, players]) => ({ rank, players }));
}

function getPlayerNameById(playerId){
  if (!playerId) return '';
  const match = latestPlayers.find(p => p.id === playerId);
  return match?.name || '';
}

function getAlivePlayers(){
  return latestPlayers.filter(p => !state.eliminated?.[p.id]);
}

function isGameStarted(){
  const hasTurn = !!state.turn?.currentPlayerId;
  const hasHands = Object.keys(state.hands || {}).length > 0;
  return hasTurn && hasHands;
}

async function maybeDeclareLastSurvivor(){
  if (!state.isHost || !state.roomCode) return;
  if (state.gameOver) return;
  if (!isGameStarted()) return;
  const alive = getAlivePlayers();
  if (alive.length !== 1) return;

  const winner = alive[0];
  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/gameOver`), {
      by: winner.id,
      reason: 'lastSurvivor',
      at: Date.now(),
      text: `${winner.name}だけが生存しました。`
    }),
    update(ref(db, `rooms/${state.roomCode}/turn`), { paused:true })
  ]);
}

function scheduleLastSurvivorCheck(){
  if (lastSurvivorTimer){
    clearTimeout(lastSurvivorTimer);
    lastSurvivorTimer = null;
  }
  if (!state.isHost || state.gameOver) return;
  if (!isGameStarted()) return;
  const alive = getAlivePlayers();
  if (alive.length !== 1) return;
  lastSurvivorTimer = setTimeout(async () => {
    lastSurvivorTimer = null;
    await maybeDeclareLastSurvivor();
  }, LAST_SURVIVOR_DELAY_MS);
}

async function setGameOverFoundFive(byPlayerId){
  if (!state.roomCode) return;
  const name = getPlayerNameById(byPlayerId) || '誰か';
  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/gameOver`), {
      by: byPlayerId || null,
      reason: 'found5',
      at: Date.now(),
      text: `${name}がロストレガシーを発見しました。`
    }),
    update(ref(db, `rooms/${state.roomCode}/turn`), { paused:true })
  ]);
}

function setPlayerHandReveal(playerId, active, { flip = false, keepFront = false } = {}){
  if (playerId === state.userId){
    myHandRow.classList.toggle('exploration-reveal', active);
    if (flip && active){
      myHandRow.classList.add('exploration-flip');
      setTimeout(() => myHandRow.classList.remove('exploration-flip'), 920);
    } else {
      myHandRow.classList.remove('exploration-flip');
    }
    return;
  }

  const fan = playerCircle.querySelector(`.player-fan[data-pid="${playerId}"]`);
  if (!fan) return;
  const wasActive = fan.classList.contains('exploration-reveal');
  fan.classList.toggle('exploration-reveal', active);
  const cards = Array.isArray(state.hands?.[playerId]?.cards) ? state.hands[playerId].cards : [];
  const miniCards = fan.querySelectorAll('.mini-card');
  if (!active && !keepFront){
    clearExplorationRevealedHand(playerId);
  }
  miniCards.forEach((card, idx) => {
    if (active){
      markExplorationRevealedHand(playerId, idx, cards[idx]);
      card.classList.add('exploration-front');
      setCardFace(card, cards[idx]);
      if (wasActive){
        card.classList.add('exploration-reopen');
        card.addEventListener('animationend', () => {
          card.classList.remove('exploration-reopen');
        }, { once:true });
      }
    } else {
      if (!keepFront){
        card.classList.remove('exploration-front');
        clearCardFaceVisual(card);
      }
    }
  });
}

function setOneRevealHand(playerId, active){
  if (!playerId) return;
  if (playerId === state.userId){
    myHandRow.classList.toggle('one-reveal', active);
    return;
  }

  const fan = playerCircle.querySelector(`.player-fan[data-pid="${playerId}"]`);
  if (!fan) return;
  fan.classList.toggle('one-reveal', active);

  const cards = Array.isArray(state.hands?.[playerId]?.cards) ? state.hands[playerId].cards : [];
  const miniCards = fan.querySelectorAll('.mini-card');
  miniCards.forEach((card, idx) => {
    if (active){
      card.classList.add('one-reveal-front');
      setCardFace(card, cards[idx]);
    } else {
      card.classList.remove('one-reveal-front');
      clearCardFaceVisual(card);
    }
  });
}

function setOneRevealTargetCard(playerId, cardIndex, active){
  if (!playerId || !Number.isFinite(Number(cardIndex))) return;
  const idx = Number(cardIndex);
  const cards = Array.isArray(state.hands?.[playerId]?.cards) ? state.hands[playerId].cards : [];
  const value = cards[idx];

  if (playerId === state.userId){
    const card = myHandEl.querySelector(`.my-card[data-index="${idx}"]`);
    if (!card) return;
    if (active){
      card.classList.add('one-reveal-target');
      if (value != null) setCardFace(card, value);
    } else {
      card.classList.remove('one-reveal-target');
    }
    return;
  }

  const fan = playerCircle.querySelector(`.player-fan[data-pid="${playerId}"]`);
  if (!fan) return;
  const card = fan.querySelector(`.mini-card[data-idx="${idx}"]`);
  if (!card) return;

  if (active){
    card.classList.add('one-reveal-front', 'one-reveal-target');
    if (value != null) setCardFace(card, value);
  } else {
    card.classList.remove('one-reveal-target', 'one-reveal-front');
    clearCardFaceVisual(card);
  }
}

function setXRevealHand(playerId, active){
  if (!playerId) return;
  if (playerId === state.userId){
    myHandRow.classList.toggle('x-reveal', active);
    return;
  }

  const fan = playerCircle.querySelector(`.player-fan[data-pid="${playerId}"]`);
  if (!fan) return;
  fan.classList.toggle('x-reveal', active);

  const cards = Array.isArray(state.hands?.[playerId]?.cards) ? state.hands[playerId].cards : [];
  const miniCards = fan.querySelectorAll('.mini-card');
  miniCards.forEach((card, idx) => {
    if (active){
      card.classList.add('x-reveal-front');
      setCardFace(card, cards[idx]);
    } else {
      card.classList.remove('x-reveal-front');
      clearCardFaceVisual(card);
    }
  });
}

function setXRevealTargetCard(playerId, cardIndex, active){
  if (!playerId || !Number.isFinite(Number(cardIndex))) return;
  const idx = Number(cardIndex);
  const cards = Array.isArray(state.hands?.[playerId]?.cards) ? state.hands[playerId].cards : [];
  const value = cards[idx];

  if (playerId === state.userId){
    const card = myHandEl.querySelector(`.my-card[data-index="${idx}"]`);
    if (!card) return;
    if (active){
      card.classList.add('x-reveal-target');
      if (value != null) setCardFace(card, value);
    } else {
      card.classList.remove('x-reveal-target');
    }
    return;
  }

  const fan = playerCircle.querySelector(`.player-fan[data-pid="${playerId}"]`);
  if (!fan) return;
  const card = fan.querySelector(`.mini-card[data-idx="${idx}"]`);
  if (!card) return;

  if (active){
    card.classList.add('x-reveal-front', 'x-reveal-target');
    if (value != null) setCardFace(card, value);
  } else {
    card.classList.remove('x-reveal-target', 'x-reveal-front');
    clearCardFaceVisual(card);
  }
}

function setExplorationTieShake(playerId, active){
  if (playerId === state.userId){
    myHandRow.classList.toggle('exploration-tie-shake', active);
    return;
  }
  const fan = playerCircle.querySelector(`.player-fan[data-pid="${playerId}"]`);
  if (!fan) return;
  fan.classList.toggle('exploration-tie-shake', active);
}

function revealExplorationCardFront(el, value){
  if (!el) return;
  if (el.classList.contains('ruins-card')){
    markExplorationRevealedRuin(Number(el.dataset.i), value);
  } else if (el.classList.contains('mini-card')){
    markExplorationRevealedHand(el.dataset.pid, Number(el.dataset.idx), value);
  }
  el.classList.add('exploration-front');
  setCardFace(el, value);
}

function clearExplorationPickedCard({ keepFront = false } = {}){
  const picked = playerCircle.querySelectorAll('.exploration-picked');
  if (!picked.length) return;
  picked.forEach((el) => {
    if (!keepFront){
      if (el.classList.contains('ruins-card')){
        clearExplorationRevealedRuin(Number(el.dataset.i));
      } else if (el.classList.contains('mini-card')){
        clearExplorationRevealedHandIndex(el.dataset.pid, el.dataset.idx);
      }
      el.classList.remove('exploration-front');
      clearCardFaceVisual(el);
    }
    el.classList.remove('exploration-picked');
  });
}

function cleanupExplorationSelection(){
  if (explorationSelectionCleanup) explorationSelectionCleanup();
  explorationSelectionCleanup = null;
  if (explorationSelectionTimer){
    clearTimeout(explorationSelectionTimer);
    explorationSelectionTimer = null;
  }
}

function revealExplorationPickFromEvent(ev){
  if (!ev) return null;
  if (!playerCircle) return null;
  const value = ev.value;
  let el = null;

  if (ev.sourceType === 'ruin' && Number.isFinite(Number(ev.sourceRuinIndex))){
    el = playerCircle.querySelector(`.ruins-card[data-i="${Number(ev.sourceRuinIndex)}"]`);
  } else if (ev.sourceType === 'hand' && ev.sourcePlayerId && Number.isFinite(Number(ev.sourceCardIndex))){
    el = playerCircle.querySelector(`.mini-card[data-pid="${ev.sourcePlayerId}"][data-idx="${Number(ev.sourceCardIndex)}"]`);
  }

  if (!el && value != null){
    const valueStr = String(value);
    el = playerCircle.querySelector(`.ruins-card[data-value="${valueStr}"]:not(.exploration-front)`)
      || playerCircle.querySelector(`.mini-card[data-value="${valueStr}"]:not(.exploration-front)`);
  }

  if (el && value != null){
    el.classList.add('exploration-picked');
    revealExplorationCardFront(el, value);
  }

  return el;
}

function waitForExplorationPickEvent({ eventId, rank, playerId } = {}){
  if (!state.roomCode) return Promise.resolve(null);
  return new Promise((resolve) => {
    const evRef = ref(db, `rooms/${state.roomCode}/explorationPickEvent`);
    const unsubscribe = onValue(evRef, (snap) => {
      const ev = snap.val();
      if (!ev || !ev.id) return;
      if (eventId && ev.eventId !== eventId) return;
      if (Number.isFinite(rank) && ev.rank !== rank) return;
      if (playerId && ev.playerId !== playerId) return;
      revealExplorationPickFromEvent(ev);
      unsubscribe();
      resolve(ev);
    });
  });
}

function waitForExplorationSelection(activePlayerId, { eventId, rank } = {}){
  if (activePlayerId !== state.userId){
    return waitForExplorationPickEvent({ eventId, rank, playerId: activePlayerId });
  }

  return new Promise((resolve) => {
    const pickables = [];
    const otherMiniCards = playerCircle.querySelectorAll(`.player-fan:not([data-pid="${state.userId}"]) .mini-card`);
    otherMiniCards.forEach((el) => {
      if (el.dataset.value && !el.classList.contains('exploration-front')) pickables.push(el);
    });
    const ruinCards = playerCircle.querySelectorAll('.ruins-card');
    ruinCards.forEach((el) => {
      if (el.dataset.value && !el.classList.contains('exploration-front')) pickables.push(el);
    });

    if (!pickables.length){
      resolve(null);
      return;
    }

    let resolved = false;
    const listeners = [];

    const finalize = async (selection) => {
      if (resolved) return;
      resolved = true;
      cleanupExplorationSelection();
      await emitExplorationPickEvent({
        eventId,
        rank,
        playerId: state.userId,
        value: selection?.value ?? null,
        sourceType: selection?.sourceType ?? null,
        sourcePlayerId: selection?.sourcePlayerId ?? null,
        sourceCardIndex: selection?.sourceCardIndex ?? null,
        sourceRuinIndex: selection?.sourceRuinIndex ?? null,
      });
      resolve({ ...selection, playerId: state.userId });
    };

    const cleanup = () => {
      listeners.forEach(({ el, handler }) => {
        el.removeEventListener('click', handler);
        el.classList.remove('exploration-pickable');
      });
    };

    explorationSelectionCleanup = cleanup;

    pickables.forEach((el) => {
      el.classList.add('exploration-pickable');
      const handler = (ev) => {
        ev.stopPropagation();
        const value = el.dataset.value;
        el.classList.add('exploration-picked');
        revealExplorationCardFront(el, value);
        const selection = { value };
        if (el.classList.contains('ruins-card')){
          selection.sourceType = 'ruin';
          selection.sourceRuinIndex = Number(el.dataset.i);
        } else if (el.classList.contains('mini-card')){
          selection.sourceType = 'hand';
          selection.sourcePlayerId = el.dataset.pid;
          selection.sourceCardIndex = Number(el.dataset.idx);
        }
        finalize(selection);
      };
      el.addEventListener('click', handler, { once:true });
      listeners.push({ el, handler });
    });

    explorationSelectionTimer = null;
  });
}

async function animateExplorationCenterDrop(value){
  const card = document.createElement('div');
  card.className = 'exploration-center-card';
  setCardFace(card, value);
  document.body.appendChild(card);

  await sleep(0);
  card.style.opacity = '1';
  card.style.transition = 'opacity 180ms ease';
  await sleep(1500);

  card.classList.add('drop');
  await sleep(760);
  card.remove();
}

async function handleExplorationSelection(value, { keepFront = false, explorerId = null } = {}){
  if (!value) return;
  if (String(value) === '5'){
    explorationStopRequested = true;
    await triggerFiveSlideSequence(explorerId);
    if (state.isHost && !state.gameOver){
      await setGameOverFoundFive(explorerId);
    }
    clearExplorationPickedCard({ keepFront });
    return;
  }
  await animateExplorationCenterDrop(value);
  clearExplorationPickedCard({ keepFront });
}

function playerHandHasFive(playerId){
  if (playerId === null || playerId === undefined) return false;
  const cards = Array.isArray(state.hands?.[playerId]?.cards) ? state.hands[playerId].cards : [];
  return cards.some((v) => String(v) === '5');
}

async function runExplorationPhaseSequence(eventId){
  if (explorationSequenceActive) return;
  explorationSequenceActive = true;
  explorationStopRequested = false;
  const revealedPlayers = new Set();

  try{
    await showExplorationFace();
    await sleep(2000);

    const groups = getExplorationGroups();
    for (const group of groups){
      if (explorationStopRequested || state.gameOver) return;
      if (!group.players.length) continue;

      group.players.forEach((pid) => {
        setPlayerHandReveal(pid, true, { flip: pid === state.userId });
        revealedPlayers.add(pid);
      });

      if (group.players.length > 1){
        await sleep(140);
        group.players.forEach((pid) => setExplorationTieShake(pid, true));
        await sleep(1500);
        group.players.forEach((pid) => setExplorationTieShake(pid, false));
        continue;
      }

      const pid = group.players[0];
      if (playerHandHasFive(pid)){
        await sleep(920);
        await animateGlobalFiveSlide();
        if (state.isHost && !state.gameOver){
          await setGameOverFoundFive(pid);
        }
        return;
      }

      const selection = await waitForExplorationSelection(pid, { eventId, rank: group.rank });
      await handleExplorationSelection(selection?.value, { keepFront: true, explorerId: selection?.playerId || pid });
      if (state.gameOver || explorationStopRequested) return;
    }
  } finally {
    revealedPlayers.forEach((pid) => setPlayerHandReveal(pid, false, { keepFront: true }));
    cleanupExplorationSelection();
    explorationSequenceActive = false;
  }
}

let isRenderingSeatTabs = false;
let latestPlayers = [];

let prevIsMyTurn = false;
let autoDrawInFlight = false;
let autoSkipInFlight = false;
let prevTurnSeq = null;

let prevMyCardsSig = null;

let lastDrawEventId = null;
let lastReshuffleEventId = null;
let lastRuinMoveEventId = null;
let lastRuinTakeEventId = null;
let lastHandTransferEventId = null;

/* ★②戻すイベント */
let lastReturnTopEventId = null;

/* ★③⑤演出イベント、④✕演出イベント */
let lastFiveSlideEventId = null;
let lastXRevealEventId = null;
let lastOneRevealEventId = null;
let lastExplorationEventId = null;

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;
  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) { mySeatIndex = Number(seatIndex); break; }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}

function updateDeckUI(){
  const n = Array.isArray(state.deck) ? state.deck.length : 0;
  deckCountEl.textContent = String(n);
  deckPile.style.opacity = n > 0 ? '1' : '.35';
  updateDeckPosition();
}

function updateDeckPosition(){
  if (!deckPile || !playerCircle) return;
  const slots = getRuinsSlots();
  const fifthFilled = !!slots[4];
  const base = getRuinSlotCenterByIndex(5);
  const x = base.x + (fifthFilled ? RUINS_GAP_X : 0);
  const y = base.y;

  const pc = playerCircle.getBoundingClientRect();
  deckPile.style.left = `${x - pc.left}px`;
  deckPile.style.top = `${y - pc.top}px`;
}

/* ===== 遺跡：常に6スロット扱い（後方互換：短い配列もOK） ===== */
function getRuinsSlots(){
  const slots = new Array(6).fill(null);
  const src = Array.isArray(state.ruins) ? state.ruins : [];
  for (let i=0;i<6;i++){
    const v = src[i];
    slots[i] = (v === undefined ? null : v);
  }
  return slots;
}
function firstEmptyRuinSlotIndex(slots){
  for (let i=0;i<6;i++){
    if (!slots[i]) return i;
  }
  return null;
}

function calcIsPlayable(){
  const myId = state.userId;
  const hand = state.hands[myId];
  const count = Array.isArray(hand?.cards) ? hand.cards.length : 0;

  if (state.gameOver) return false;

  if (ui.effect2Selecting) return false;
  if (ui.effect3Selecting) return false;
  if (ui.effect4Selecting) return false;
  if (ui.effect6Selecting) return false;
  if (ui.effect7Picking || ui.effect7Placing) return false;
  if (ui.effect8Selecting || ui.effect8Returning) return false;

  // 脱落者は操作不可
  if (state.eliminated?.[myId]) return false;

  return state.isMyTurn && !state.turn.paused && (count === 2);
}

function updateTurnUI(){
  state.isMyTurn = !!state.turn.currentPlayerId && (state.turn.currentPlayerId === state.userId);
  state.isPlayable = calcIsPlayable();

  myHandEl.classList.toggle('is-playable', state.isPlayable);
  myHandEl.classList.toggle('effect2-pick', ui.effect2Selecting);
  myHandEl.classList.toggle('effect6-pick', ui.effect6Selecting);
  myHandEl.classList.toggle('effect7-place', ui.effect7Placing);
  myHandEl.classList.toggle('effect8-return', ui.effect8Returning);

  playerCircle.classList.toggle('turn-paused', !!state.turn.paused);

  if (state.gameOver){
    gameOverPop.classList.toggle('found5', state.gameOver?.reason === 'found5');
    if (state.gameOver?.reason === 'found5'){
      showGameOver(state.gameOver?.text || 'ゲーム終了');
      hideCenterNotice();
    } else if (state.gameOver?.reason === 'lastSurvivor'){
      hideGameOver();
      showCenterNotice(state.gameOver?.text || '');
    } else {
      showGameOver(state.gameOver?.text || 'ゲーム終了');
      hideCenterNotice();
    }
  } else {
    gameOverPop.classList.remove('found5');
    hideGameOver();
    hideCenterNotice();
  }
}

function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost) hostSettingsBtn.classList.add('visible');
  else { hostSettingsBtn.classList.remove('visible'); startPop.classList.add('hidden'); }
  helpBtn.classList.add('visible');
}

function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();
  });
}

function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
  });
}

function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  });
}

function subscribePlayed(){
  const pRef = ref(db, `rooms/${state.roomCode}/played`);
  onValue(pRef, snap => {
    state.played = snap.val() || {};
    renderHands();
  });
}

function subscribeDeck(){
  const deckRef = ref(db, `rooms/${state.roomCode}/deck`);
  onValue(deckRef, snap => {
    state.deck = snap.val() || [];
    updateDeckUI();
  });
}

function subscribeRuins(){
  const rRef = ref(db, `rooms/${state.roomCode}/ruins`);
  onValue(rRef, snap => {
    const v = snap.val();
    state.ruins = Array.isArray(v) ? v : [];
    renderHands();
    updateDeckPosition();
  });
}

function subscribeEliminated(){
  const eRef = ref(db, `rooms/${state.roomCode}/eliminated`);
  onValue(eRef, snap => {
    state.eliminated = snap.val() || {};
    updateTurnUI();
    scheduleLastSurvivorCheck();
  });
}

function subscribeGameOver(){
  const gRef = ref(db, `rooms/${state.roomCode}/gameOver`);
  onValue(gRef, snap => {
    state.gameOver = snap.val() || null;
    if (state.gameOver && lastSurvivorTimer){
      clearTimeout(lastSurvivorTimer);
      lastSurvivorTimer = null;
    }
    if (state.gameOver){
      explorationStopRequested = true;
      cleanupExplorationSelection();
    }
    updateTurnUI();
  });
}

function subscribeEffect2(){
  const eRef = ref(db, `rooms/${state.roomCode}/effect2`);
  onValue(eRef, snap => {
    state.effect2 = snap.val() || null;

    const mine = state.effect2 && state.effect2.playerId === state.userId;
    const selecting = !!(mine && state.effect2.phase === 'select');

    if (selecting !== ui.effect2Selecting){
      ui.effect2Selecting = selecting;
      ui.effect2SelectedIndex = null;
      ui.effect2DropPending = false;
      if (!selecting && e2drag.active) cleanupE2Drag();
      updateTurnUI();
      renderMyHand();
    }
  });
}

/* ★③ */
function subscribeEffect3(){
  const eRef = ref(db, `rooms/${state.roomCode}/effect3`);
  onValue(eRef, snap => {
    state.effect3 = snap.val() || null;

    const mine = state.effect3 && state.effect3.playerId === state.userId;
    const selecting = !!(mine && state.effect3.phase === 'select');
    ui.effect3Selecting = selecting;

    // 使用者だけ拡大表示
    if (mine && state.effect3 && state.effect3.phase === 'confirm' && !state.gameOver){
      const v = state.effect3.revealed;
      if (String(v) === '5'){
        hidePeekCard();
        hideConfirmPop();
      } else {
        if (v !== undefined && v !== null) showPeekCard(v);
        showConfirmPop('閉じてもいいですか', async () => {
          await finishEffect3AndAdvance();
        });
      }
    } else {
      // ③中じゃない / 自分じゃない → 非表示
      if (!selecting){
        hidePeekCard();
        // confirmPopは「今のconfirmActionが③のもの」の時だけ消すのが理想だけど、
        // ここでは「③ confirmでないなら隠す」でOK（他効果は別subscribeで再表示される）
        hideConfirmPop();
      }
    }

    updateTurnUI();
    renderHands();
  });
}

/* ★④ */
function subscribeEffect4(){
  const eRef = ref(db, `rooms/${state.roomCode}/effect4`);
  onValue(eRef, snap => {
    state.effect4 = snap.val() || null;

    const mine = state.effect4 && state.effect4.playerId === state.userId;
    const selecting = !!(mine && state.effect4.phase === 'select');
    ui.effect4Selecting = selecting;

    if (mine && state.effect4 && state.effect4.phase === 'confirm' && !state.gameOver){
      const v = state.effect4.revealed;
      if (String(v) === 'x' || String(v) === '✕'){
        hidePeekCard();
        hideConfirmPop();
      } else {
        if (v !== undefined && v !== null) showPeekCard(v);

        showConfirmPop('閉じてもいいですか', async () => {
          await finishEffect4AndAdvance();
        });
      }
    } else {
      if (!selecting){
        // ④中じゃない / 自分じゃない → 非表示
        hidePeekCard();
        hideConfirmPop();
      }
    }

    updateTurnUI();
    renderHands();
  });
}

function subscribeEffect6(){
  const eRef = ref(db, `rooms/${state.roomCode}/effect6`);
  onValue(eRef, snap => {
    state.effect6 = snap.val() || null;

    const mine = state.effect6 && state.effect6.playerId === state.userId;
    const selecting = !!(mine && state.effect6.phase === 'select');

    if (selecting !== ui.effect6Selecting){
      ui.effect6Selecting = selecting;
      ui.selectedIndex = null;
      updateTurnUI();
      renderMyHand();
    }
  });
}

function subscribeEffect7(){
  const eRef = ref(db, `rooms/${state.roomCode}/effect7`);
  onValue(eRef, snap => {
    state.effect7 = snap.val() || null;

    const mine = state.effect7 && state.effect7.playerId === state.userId;
    const picking = !!(mine && state.effect7.phase === 'pickRuins');
    const placing = !!(mine && state.effect7.phase === 'placeBack');

    ui.effect7Picking = picking;
    ui.effect7Placing = placing;
    ui.effect7TargetSlot = mine ? (state.effect7?.targetSlotIndex ?? null) : null;
    ui.effect7PickedValue = mine ? (state.effect7?.pickedValue ?? null) : null;
    if (!picking && e7pickDrag.active) cleanupE7PickDrag({ keepSourceHidden: true });

    updateTurnUI();
    renderHands();
  });
}

function subscribeEffect8(){
  const eRef = ref(db, `rooms/${state.roomCode}/effect8`);
  onValue(eRef, snap => {
    state.effect8 = snap.val() || null;

    const mine = state.effect8 && state.effect8.playerId === state.userId;
    const selecting = !!(mine && state.effect8.phase === 'select');
    const returning = !!(mine && state.effect8.phase === 'return');

    ui.effect8Selecting = selecting;
    ui.effect8Returning = returning;
    ui.effect8TargetPlayerId = mine ? (state.effect8?.targetPlayerId ?? null) : null;

    if (!returning && e8drag.active){
      cleanupE8Drag();
    }

    updateTurnUI();
    renderHands();
  });
}

function subscribeTurn(){
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);
  onValue(turnRef, async snap => {
    const t = snap.val() || {};
    const nextTurnSeq = Number(t.turnSeq || 0);
    const nextTurnPlayerId = t.currentPlayerId || null;

    if ((nextTurnSeq === 1 && prevTurnSeq !== 1) || (nextTurnSeq === 0 && prevTurnSeq && prevTurnSeq !== 0)){
      resetExplorationState();
    }
    prevTurnSeq = nextTurnSeq;

    state.turn = {
      currentPlayerId: nextTurnPlayerId,
      turnSeq: nextTurnSeq,
      drawn: !!t.drawn,
      paused: !!t.paused
    };
    state.turnPlayerId = state.turn.currentPlayerId;
    updateTurnUI();

    // ★脱落者の手番なら（ホストが）自動で飛ばす
    if (!state.gameOver && state.isHost && state.turn.currentPlayerId && state.eliminated?.[state.turn.currentPlayerId] && !autoSkipInFlight){
      autoSkipInFlight = true;
      try{
        await advanceTurnToNextPlayer();
      } finally {
        autoSkipInFlight = false;
      }
      return;
    }

    if (!prevIsMyTurn && state.isMyTurn){
      maybeAutoDrawAtTurnStart();
    }
    prevIsMyTurn = state.isMyTurn;
  });
}

function subscribeDrawEvent(){
  const evRef = ref(db, `rooms/${state.roomCode}/drawEvent`);
  onValue(evRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastDrawEventId) return;
    lastDrawEventId = ev.id;

    const now = Date.now();
    if (ev.at && (now - ev.at) > 8000) return;

    const pid = ev.playerId;
    if (!pid) return;

    animateDrawFromDeckToPlayer(pid);
  });
}

function subscribeReturnTopEvent(){
  const evRef = ref(db, `rooms/${state.roomCode}/returnTopEvent`);
  onValue(evRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastReturnTopEventId) return;
    lastReturnTopEventId = ev.id;

    const now = Date.now();
    if (ev.at && (now - ev.at) > 12000) return;

    const pid = ev.fromPlayerId;
    if (!pid) return;

    // 自分はローカルで「表の番号」アニメを出すので重複防止
    if (pid === state.userId) return;

    animateReturnTopFromPlayerAnchorToDeck(pid);
  });
}

function subscribeReshuffleEvent(){
  const evRef = ref(db, `rooms/${state.roomCode}/reshuffleEvent`);
  onValue(evRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastReshuffleEventId) return;
    lastReshuffleEventId = ev.id;

    const now = Date.now();
    if (ev.at && (now - ev.at) > 12000) return;

    const count = Number(ev.count || 0);
    animateReshufflePlayedToDeck(count);
  });
}

/* 遺跡移動アニメ（他プレイヤーの手札→遺跡） */
function subscribeRuinMoveEvent(){
  const evRef = ref(db, `rooms/${state.roomCode}/ruinMoveEvent`);
  onValue(evRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastRuinMoveEventId) return;
    lastRuinMoveEventId = ev.id;

    const now = Date.now();
    if (ev.at && (now - ev.at) > 12000) return;

    const fromPid = ev.fromPlayerId;
    const cardValue = ev.cardValue;
    const slotIndex = Number(ev.slotIndex || 0);
    const mode = ev.mode || null;

    if (!fromPid) return;
    if (fromPid === state.userId && mode !== 'oneReveal' && mode !== 'xReveal') return;

    if (mode === 'oneReveal'){
      animateOneRevealMoveToRuin(fromPid, String(cardValue ?? ''), slotIndex);
      if (pendingOneRevealTarget && pendingOneRevealTarget.playerId === fromPid){
        setOneRevealTargetCard(fromPid, pendingOneRevealTarget.cardIndex, false);
        pendingOneRevealTarget = null;
      }
      return;
    }
    if (mode === 'xReveal'){
      const idx = pendingXRevealTarget && pendingXRevealTarget.playerId === fromPid
        ? Number(pendingXRevealTarget.cardIndex)
        : null;
      if (Number.isFinite(idx)){
        animateXRevealMoveToRuin(fromPid, idx, slotIndex);
      } else {
        animateMoveFromPlayerToRuin(fromPid, String(cardValue ?? ''), slotIndex);
      }
      return;
    }

    animateMoveFromPlayerToRuin(fromPid, String(cardValue ?? ''), slotIndex);
  });
}

/* ★追加：⑦ 遺跡→手札（他プレイヤー視点でも「遺跡→その人」へ飛ぶ） */
function subscribeRuinTakeEvent(){
  const evRef = ref(db, `rooms/${state.roomCode}/ruinTakeEvent`);
  onValue(evRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastRuinTakeEventId) return;
    lastRuinTakeEventId = ev.id;

    const now = Date.now();
    if (ev.at && (now - ev.at) > 12000) return;

    const toPid = ev.toPlayerId;
    const cardValue = ev.cardValue;
    const slotIndex = Number(ev.slotIndex || 0);

    if (!toPid) return;
    if (toPid === state.userId) return;

    animateTakeFromRuinToPlayerAnchor(toPid, slotIndex, String(cardValue ?? ''));
  });
}

/* ★⑧：手札↔手札（他プレイヤー視点：裏向き移動） */
function subscribeHandTransferEvent(){
  const evRef = ref(db, `rooms/${state.roomCode}/handTransferEvent`);
  onValue(evRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastHandTransferEventId) return;
    lastHandTransferEventId = ev.id;

    const now = Date.now();
    if (ev.at && (now - ev.at) > 12000) return;

    const fromPid = ev.fromPlayerId;
    const toPid = ev.toPlayerId;
    const byPid = ev.byPlayerId;

    if (!fromPid || !toPid) return;
    if (byPid && byPid === state.userId) return;

    animateBackMoveBetweenPlayers(fromPid, toPid);
  });
}

/* ★③：5スライド演出イベント */
function subscribeFiveSlideEvent(){
  const evRef = ref(db, `rooms/${state.roomCode}/fiveSlideEvent`);
  onValue(evRef, async snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastFiveSlideEventId) return;
    lastFiveSlideEventId = ev.id;

    const now = Date.now();
    if (ev.at && (now - ev.at) > 20000) return;

    await animateGlobalFiveSlide();
  });
}

/* ★④：✕演出イベント */
function subscribeXRevealEvent(){
  const evRef = ref(db, `rooms/${state.roomCode}/xRevealEvent`);
  onValue(evRef, async snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastXRevealEventId) return;
    lastXRevealEventId = ev.id;

    const now = Date.now();
    if (ev.at && (now - ev.at) > 20000) return;

    const mode = ev.mode || 'effect38';
    const hasTarget = ev.targetPlayerId && Number.isFinite(Number(ev.targetCardIndex));
    if ((mode === 'effect38' || mode === 'effect4') && hasTarget){
      showTempArrow({
        fromPid: ev.fromPlayerId,
        toPid: ev.targetPlayerId,
        targetCardIndex: ev.targetCardIndex,
        showEye: true,
        durationMs: XRAY_MINI_DELAY_MS,
      });
      setXRevealTargetCard(ev.targetPlayerId, ev.targetCardIndex, true);
      const rect = getPlayerCardRect(ev.targetPlayerId, ev.targetCardIndex);
      pendingXRevealTarget = {
        playerId: ev.targetPlayerId,
        cardIndex: Number(ev.targetCardIndex),
        rect: rect ? { left: rect.left, top: rect.top, width: rect.width, height: rect.height } : null,
      };
      await sleep(XRAY_MINI_DELAY_MS);
      await animateGlobalXReveal(mode);
      await sleep(XRAY_MINI_DELAY_MS);
      if (mode === 'effect38'){
        await animateMiniXToDiscard(ev.targetPlayerId, ev.targetCardIndex);
        setXRevealTargetCard(ev.targetPlayerId, ev.targetCardIndex, false);
        pendingXRevealTarget = null;
      }
    } else {
      await animateGlobalXReveal(mode);
    }
  });
}

/* ★1：拡大演出イベント */
function subscribeOneRevealEvent(){
  const evRef = ref(db, `rooms/${state.roomCode}/oneRevealEvent`);
  onValue(evRef, async snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastOneRevealEventId) return;
    lastOneRevealEventId = ev.id;

    const now = Date.now();
    if (ev.at && (now - ev.at) > 20000) return;

    if (ev.targetPlayerId && Number.isFinite(Number(ev.targetCardIndex))){
      showTempArrow({
        fromPid: ev.fromPlayerId,
        toPid: ev.targetPlayerId,
        targetCardIndex: ev.targetCardIndex,
        showEye: true,
        durationMs: ONE_REVEAL_DELAY_MS,
      });
      await sleep(ONE_REVEAL_DELAY_MS);
      setOneRevealTargetCard(ev.targetPlayerId, ev.targetCardIndex, true);
      pendingOneRevealTarget = {
        playerId: ev.targetPlayerId,
        cardIndex: Number(ev.targetCardIndex),
      };
    }

    await animateGlobalOneReveal(ev.targetPlayerId || null);
  });
}

function subscribeExplorationFaceEvent(){
  const evRef = ref(db, `rooms/${state.roomCode}/explorationFaceEvent`);
  onValue(evRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastExplorationEventId) return;
    lastExplorationEventId = ev.id;

    const now = Date.now();
    if (ev.at && (now - ev.at) > 20000) return;

    runExplorationPhaseSequence(ev.id);
  });
}

function renderMyIdentity(){
  if (!myIdentityEl) return;
  myIdentityEl.classList.add('hidden');
  myIdentityEl.textContent = '';
}

/* ドラッグ状態（通常プレイ） */
let drag = { active:false, cardIndex:null, pointerId:null, ghostEl:null, overCenter:false, sourceEl:null };

/* ②ドラッグ状態（山札へ戻す） */
let e2drag = { active:false, cardIndex:null, pointerId:null, ghostEl:null, overDeck:false, sourceEl:null };

/* ⑥ドラッグ状態（遺跡へドロップ） */
let e6drag = { active:false, cardIndex:null, pointerId:null, ghostEl:null, overSlot:false, slotIndex:null, sourceEl:null };

/* ★⑦ドラッグ状態（指定スロットへドロップ） */
let e7drag = { active:false, cardIndex:null, pointerId:null, ghostEl:null, overSlot:false, slotIndex:null, sourceEl:null };

/* ★⑦ドラッグ状態（遺跡→手札） */
let e7pickDrag = { active:false, slotIndex:null, pointerId:null, ghostEl:null, overHand:false, sourceEl:null };

/* ★⑧ドラッグ状態（相手へ返す） */
let e8drag = { active:false, cardIndex:null, pointerId:null, ghostEl:null, overTarget:false, targetPlayerId:null, sourceEl:null };

function cleanupDrag(){
  if (drag.ghostEl) drag.ghostEl.remove();
  if (drag.sourceEl) drag.sourceEl.classList.remove('drag-source-hidden');
  drag.active = false;
  drag.cardIndex = null;
  drag.pointerId = null;
  drag.ghostEl = null;
  drag.sourceEl = null;
  drag.overCenter = false;
  centerArea.classList.remove('active-drop');
  centerArea.classList.remove('drag-hint');
}
function cleanupE2Drag({ keepSourceHidden = false } = {}){
  if (e2drag.ghostEl) e2drag.ghostEl.remove();
  if (e2drag.sourceEl && !keepSourceHidden) e2drag.sourceEl.classList.remove('drag-source-hidden');
  e2drag.active = false;
  e2drag.cardIndex = null;
  e2drag.pointerId = null;
  e2drag.ghostEl = null;
  e2drag.sourceEl = null;
  e2drag.overDeck = false;
  setDeckDropActive(false);
  setDeckDropHint(false);
}
function cleanupE6Drag({ keepSourceHidden = false } = {}){
  if (e6drag.ghostEl) e6drag.ghostEl.remove();
  if (e6drag.sourceEl && !keepSourceHidden) e6drag.sourceEl.classList.remove('drag-source-hidden');
  e6drag.active = false;
  e6drag.cardIndex = null;
  e6drag.pointerId = null;
  e6drag.ghostEl = null;
  e6drag.sourceEl = null;
  e6drag.overSlot = false;
  e6drag.slotIndex = null;
  clearRuinSlotHighlights();
}
function cleanupE7Drag({ keepSourceHidden = false } = {}){
  if (e7drag.ghostEl) e7drag.ghostEl.remove();
  if (e7drag.sourceEl && !keepSourceHidden) e7drag.sourceEl.classList.remove('drag-source-hidden');
  e7drag.active = false;
  e7drag.cardIndex = null;
  e7drag.pointerId = null;
  e7drag.ghostEl = null;
  e7drag.sourceEl = null;
  e7drag.overSlot = false;
  e7drag.slotIndex = null;
  clearRuinSlotHighlights();
}
function cleanupE7PickDrag({ keepSourceHidden = false } = {}){
  if (e7pickDrag.ghostEl) e7pickDrag.ghostEl.remove();
  if (e7pickDrag.sourceEl && !keepSourceHidden) e7pickDrag.sourceEl.classList.remove('drag-source-hidden');
  e7pickDrag.active = false;
  e7pickDrag.slotIndex = null;
  e7pickDrag.pointerId = null;
  e7pickDrag.ghostEl = null;
  e7pickDrag.sourceEl = null;
  e7pickDrag.overHand = false;
  removeRuinPickListeners();
  setHandDropActive(false);
  setHandDropHint(false);
}
function getEffect8TargetEl(){
  if (!ui.effect8TargetPlayerId) return null;
  return playerCircle.querySelector(`.player-fan[data-pid="${ui.effect8TargetPlayerId}"]`);
}
function setEffect8TargetHighlight(active){
  const el = getEffect8TargetEl();
  if (!el) return;
  el.classList.toggle('effect8-drop-target', !!active);
}
function setEffect8TargetActive(active){
  const el = getEffect8TargetEl();
  if (!el) return;
  el.classList.toggle('effect8-drop-active', !!active);
}
function cleanupE8Drag({ keepSourceHidden = false } = {}){
  if (e8drag.ghostEl) e8drag.ghostEl.remove();
  if (e8drag.sourceEl && !keepSourceHidden) e8drag.sourceEl.classList.remove('drag-source-hidden');
  e8drag.active = false;
  e8drag.cardIndex = null;
  e8drag.pointerId = null;
  e8drag.ghostEl = null;
  e8drag.sourceEl = null;
  e8drag.overTarget = false;
  e8drag.targetPlayerId = null;
  setEffect8TargetActive(false);
  setEffect8TargetHighlight(false);
}

function isPointInRect(x, y, rect){ return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom; }

function getRuinSlotEl(slotIndex){
  return playerCircle.querySelector(`.ruins-slot[data-i="${slotIndex}"]`);
}
function clearRuinSlotHighlights(){
  const all = playerCircle.querySelectorAll('.ruins-slot');
  all.forEach(el => {
    el.classList.remove('next-target');
    el.classList.remove('active-drop');
    el.classList.remove('hint-target');
  });
  const area = playerCircle.querySelector('.ruins-area');
  if (area) area.classList.remove('drop-enabled');
}
function setNextRuinSlotHighlight(slotIndex){
  clearRuinSlotHighlights();
  const area = playerCircle.querySelector('.ruins-area');
  if (area) area.classList.add('drop-enabled');
  const el = getRuinSlotEl(slotIndex);
  if (el) el.classList.add('next-target');
}
function setHintRuinSlotHighlight(slotIndex){
  clearRuinSlotHighlights();
  const area = playerCircle.querySelector('.ruins-area');
  if (area) area.classList.add('drop-enabled');
  const el = getRuinSlotEl(slotIndex);
  if (el) el.classList.add('hint-target');
}
function setRuinSlotActive(slotIndex, active){
  const el = getRuinSlotEl(slotIndex);
  if (!el) return;
  el.classList.toggle('active-drop', !!active);
}
function setDeckDropHint(active){
  if (!deckPile) return;
  deckPile.classList.toggle('effect2-drop-target', !!active);
}
function setDeckDropActive(active){
  if (!deckPile) return;
  deckPile.classList.toggle('effect2-drop-active', !!active);
}
function setHandDropHint(active){
  if (!myHandRow) return;
  myHandRow.classList.toggle('effect7-pick-target', !!active);
}
function setHandDropActive(active){
  if (!myHandRow) return;
  myHandRow.classList.toggle('effect7-pick-active', !!active);
}

const ZOOM_TAP_DISTANCE = 6;
const zoomTapState = {
  active: false,
  pointerId: null,
  startX: 0,
  startY: 0,
  target: null,
  moved: false,
};

function isFaceUpMiniCard(cardEl){
  return cardEl.classList.contains('exploration-front')
    || cardEl.classList.contains('one-reveal-front')
    || cardEl.classList.contains('x-reveal-front');
}

function isZoomableCardElement(cardEl){
  if (!cardEl) return false;
  if (!cardEl.dataset.value) return false;
  if (cardEl.classList.contains('pickable')) return false;
  if (peekOverlay && !peekOverlay.classList.contains('hidden')) return false;
  if (cardEl.classList.contains('my-card')) return true;
  if (cardEl.classList.contains('played-card')) return true;
  if (cardEl.classList.contains('mini-card')) return isFaceUpMiniCard(cardEl);
  return false;
}

function openZoomFromCard(cardEl){
  if (!zoomOverlay || !zoomCardEl) return false;
  if (!isZoomableCardElement(cardEl)) return false;
  const value = cardEl.dataset.value;
  if (!value) return false;
  showZoomCard(value);
  return true;
}

function clearZoomTapState(){
  window.removeEventListener('pointermove', onZoomTapMove);
  window.removeEventListener('pointerup', onZoomTapEnd);
  window.removeEventListener('pointercancel', onZoomTapEnd);
  zoomTapState.active = false;
  zoomTapState.pointerId = null;
  zoomTapState.target = null;
  zoomTapState.moved = false;
}

function onZoomTapMove(e){
  if (!zoomTapState.active || zoomTapState.pointerId !== e.pointerId) return;
  if (zoomTapState.moved) return;
  const dx = e.clientX - zoomTapState.startX;
  const dy = e.clientY - zoomTapState.startY;
  if (Math.hypot(dx, dy) > ZOOM_TAP_DISTANCE){
    zoomTapState.moved = true;
  }
}

function onZoomTapEnd(e){
  if (!zoomTapState.active || zoomTapState.pointerId !== e.pointerId) return;
  const target = zoomTapState.target;
  const moved = zoomTapState.moved;
  clearZoomTapState();
  if (moved) return;
  if (drag.active || e2drag.active || e6drag.active || e7drag.active || e7pickDrag.active || e8drag.active) return;
  openZoomFromCard(target);
}

function startZoomTap(e, cardEl){
  if (zoomTapState.active) return;
  if (!isZoomableCardElement(cardEl)) return;
  zoomTapState.active = true;
  zoomTapState.pointerId = e.pointerId;
  zoomTapState.startX = e.clientX;
  zoomTapState.startY = e.clientY;
  zoomTapState.target = cardEl;
  zoomTapState.moved = false;
  window.addEventListener('pointermove', onZoomTapMove, { passive:true });
  window.addEventListener('pointerup', onZoomTapEnd, { passive:false });
  window.addEventListener('pointercancel', onZoomTapEnd, { passive:false });
}

/* ====== 手札カード pointer handlers ====== */
function onCardPointerDown(e){
  const cardEl = e.currentTarget;
  startZoomTap(e, cardEl);

  // ★ゲーム終了/脱落/③④選択中はドラッグ禁止
  if (state.gameOver) return;
  if (state.eliminated?.[state.userId]) return;
  if (ui.effect3Selecting || ui.effect4Selecting) return;
  if (ui.effect8Selecting) return;

  if (ui.effect2Selecting){
    const idx = Number(cardEl.dataset.index);
    if (!Number.isFinite(idx)) return;

    e2drag.active = true;
    e2drag.cardIndex = idx;
    e2drag.pointerId = e.pointerId;
    e2drag.overDeck = false;

    e2drag.sourceEl = cardEl;
    cardEl.classList.add('drag-source-hidden');

    const ghost = document.createElement('div');
    ghost.className = 'drag-ghost';
    setCardFace(ghost, cardEl.dataset.value || cardEl.textContent);
    document.body.appendChild(ghost);
    e2drag.ghostEl = ghost;

    ghost.style.left = `${e.clientX}px`;
    ghost.style.top  = `${e.clientY}px`;

    setDeckDropHint(true);
    setDeckDropActive(false);

    cardEl.setPointerCapture(e.pointerId);
    e.preventDefault();
    return;
  }

  if (ui.effect7Placing){
    const idx = Number(cardEl.dataset.index);
    if (!Number.isFinite(idx)) return;

    const slotIndex = Number(ui.effect7TargetSlot);
    if (!Number.isFinite(slotIndex)) return;

    setHintRuinSlotHighlight(slotIndex);

    e7drag.active = true;
    e7drag.cardIndex = idx;
    e7drag.pointerId = e.pointerId;
    e7drag.slotIndex = slotIndex;
    e7drag.overSlot = false;

    e7drag.sourceEl = cardEl;
    cardEl.classList.add('drag-source-hidden');

    const ghost = createBackGhost();
    document.body.appendChild(ghost);
    e7drag.ghostEl = ghost;

    ghost.style.left = `${e.clientX}px`;
    ghost.style.top  = `${e.clientY}px`;

    setRuinSlotActive(slotIndex, false);

    cardEl.setPointerCapture(e.pointerId);
    e.preventDefault();
    return;
  }

  if (ui.effect8Returning){
    const idx = Number(cardEl.dataset.index);
    if (!Number.isFinite(idx)) return;

    const targetId = ui.effect8TargetPlayerId;
    if (!targetId) return;

    setEffect8TargetHighlight(true);

    e8drag.active = true;
    e8drag.cardIndex = idx;
    e8drag.pointerId = e.pointerId;
    e8drag.targetPlayerId = targetId;
    e8drag.overTarget = false;

    e8drag.sourceEl = cardEl;
    cardEl.classList.add('drag-source-hidden');

    const ghost = document.createElement('div');
    ghost.className = 'drag-ghost';
    setCardFace(ghost, cardEl.dataset.value || cardEl.textContent);
    document.body.appendChild(ghost);
    e8drag.ghostEl = ghost;

    ghost.style.left = `${e.clientX}px`;
    ghost.style.top  = `${e.clientY}px`;

    setEffect8TargetActive(false);

    cardEl.setPointerCapture(e.pointerId);
    e.preventDefault();
    return;
  }

  if (ui.effect6Selecting){
    const idx = Number(cardEl.dataset.index);
    if (!Number.isFinite(idx)) return;

    const slots = getRuinsSlots();
    const slotIndex = firstEmptyRuinSlotIndex(slots);
    if (slotIndex === null) return;

    setNextRuinSlotHighlight(slotIndex);

    e6drag.active = true;
    e6drag.cardIndex = idx;
    e6drag.pointerId = e.pointerId;
    e6drag.slotIndex = slotIndex;
    e6drag.overSlot = false;

    e6drag.sourceEl = cardEl;
    cardEl.classList.add('drag-source-hidden');

    const ghost = document.createElement('div');
    ghost.className = 'drag-ghost';
    setCardFace(ghost, cardEl.dataset.value || cardEl.textContent);
    document.body.appendChild(ghost);
    e6drag.ghostEl = ghost;

    ghost.style.left = `${e.clientX}px`;
    ghost.style.top  = `${e.clientY}px`;

    setRuinSlotActive(slotIndex, false);

    cardEl.setPointerCapture(e.pointerId);
    e.preventDefault();
    return;
  }

  if (!state.isPlayable) return;
  if ((cardEl.dataset.value || '').trim() === '5') return;

  const idx = Number(cardEl.dataset.index);
  if (!Number.isFinite(idx)) return;

  drag.active = true;
  drag.cardIndex = idx;
  drag.pointerId = e.pointerId;

  drag.sourceEl = cardEl;
  cardEl.classList.add('drag-source-hidden');

  const ghost = document.createElement('div');
  ghost.className = 'drag-ghost';
  setCardFace(ghost, cardEl.dataset.value || cardEl.textContent);
  document.body.appendChild(ghost);
  drag.ghostEl = ghost;

  ghost.style.left = `${e.clientX}px`;
  ghost.style.top  = `${e.clientY}px`;

  centerArea.classList.add('drag-hint');
  centerArea.classList.remove('active-drop');
  drag.overCenter = false;

  cardEl.setPointerCapture(e.pointerId);
  e.preventDefault();
}

function onCardPointerMove(e){
  if (e2drag.active && e2drag.pointerId === e.pointerId && e2drag.ghostEl){
    e2drag.ghostEl.style.left = `${e.clientX}px`;
    e2drag.ghostEl.style.top  = `${e.clientY}px`;

    const rect = deckPile.getBoundingClientRect();
    const over = isPointInRect(e.clientX, e.clientY, rect);
    e2drag.overDeck = over;
    setDeckDropActive(over);
    return;
  }

  if (e8drag.active && e8drag.pointerId === e.pointerId && e8drag.ghostEl){
    e8drag.ghostEl.style.left = `${e.clientX}px`;
    e8drag.ghostEl.style.top  = `${e.clientY}px`;

    const targetEl = getEffect8TargetEl();
    if (targetEl){
      const r = targetEl.getBoundingClientRect();
      const over = isPointInRect(e.clientX, e.clientY, r);
      e8drag.overTarget = over;
      setEffect8TargetActive(over);
    }
    return;
  }

  if (e7drag.active && e7drag.pointerId === e.pointerId && e7drag.ghostEl){
    e7drag.ghostEl.style.left = `${e.clientX}px`;
    e7drag.ghostEl.style.top  = `${e.clientY}px`;

    const slotIndex = e7drag.slotIndex;
    const slotEl = getRuinSlotEl(slotIndex);
    if (slotEl){
      const r = slotEl.getBoundingClientRect();
      const over = isPointInRect(e.clientX, e.clientY, r);
      e7drag.overSlot = over;
      setRuinSlotActive(slotIndex, over);
    }
    return;
  }

  if (e6drag.active && e6drag.pointerId === e.pointerId && e6drag.ghostEl){
    e6drag.ghostEl.style.left = `${e.clientX}px`;
    e6drag.ghostEl.style.top  = `${e.clientY}px`;

    const slotIndex = e6drag.slotIndex;
    const slotEl = getRuinSlotEl(slotIndex);
    if (slotEl){
      const r = slotEl.getBoundingClientRect();
      const over = isPointInRect(e.clientX, e.clientY, r);
      e6drag.overSlot = over;
      setRuinSlotActive(slotIndex, over);
    }
    return;
  }

  if (!drag.active || drag.pointerId !== e.pointerId || !drag.ghostEl) return;

  drag.ghostEl.style.left = `${e.clientX}px`;
  drag.ghostEl.style.top  = `${e.clientY}px`;

  const rect = centerArea.getBoundingClientRect();
  const over = isPointInRect(e.clientX, e.clientY, rect);
  drag.overCenter = over;
  centerArea.classList.toggle('active-drop', over);
}

async function onCardPointerUp(e){
  const cardEl = e.currentTarget;

  if (e2drag.active && e2drag.pointerId === e.pointerId){
    const idx = e2drag.cardIndex;
    const shouldDrop = e2drag.overDeck;
    cleanupE2Drag({ keepSourceHidden: shouldDrop });
    try { cardEl.releasePointerCapture(e.pointerId); } catch {}
    if (shouldDrop){
      ui.effect2SelectedIndex = idx;
      ui.effect2DropPending = true;
      await handleEffect2Pick(idx, cardEl);
    }
    return;
  }

  if (e8drag.active && e8drag.pointerId === e.pointerId){
    const idx = e8drag.cardIndex;
    const shouldDrop = e8drag.overTarget;
    cleanupE8Drag({ keepSourceHidden: shouldDrop });
    try { cardEl.releasePointerCapture(e.pointerId); } catch {}
    if (shouldDrop) await handleEffect8Drop(idx);
    return;
  }

  if (e7drag.active && e7drag.pointerId === e.pointerId){
    const idx = e7drag.cardIndex;
    const shouldDrop = e7drag.overSlot;
    cleanupE7Drag({ keepSourceHidden: shouldDrop });
    try { cardEl.releasePointerCapture(e.pointerId); } catch {}
    if (shouldDrop) await handleEffect7Drop(idx);
    return;
  }

  if (e6drag.active && e6drag.pointerId === e.pointerId){
    const idx = e6drag.cardIndex;
    const shouldDrop = e6drag.overSlot;
    cleanupE6Drag({ keepSourceHidden: shouldDrop });
    try { cardEl.releasePointerCapture(e.pointerId); } catch {}
    if (shouldDrop) await handleEffect6Drop(idx);
    return;
  }

  if (!drag.active || drag.pointerId !== e.pointerId) return;

  const idx = drag.cardIndex;
  const shouldPlay = drag.overCenter;
  cleanupDrag();

  if (shouldPlay) await playCardFromHand(idx);
  try { cardEl.releasePointerCapture(e.pointerId); } catch {}
}

const ruinPickListeners = {
  move: null,
  up: null,
  cancel: null,
};

function addRuinPickListeners(){
  if (ruinPickListeners.move) return;
  ruinPickListeners.move = (ev) => onRuinPointerMove(ev);
  ruinPickListeners.up = (ev) => onRuinPointerUp(ev);
  ruinPickListeners.cancel = (ev) => onRuinPointerUp(ev);
  window.addEventListener('pointermove', ruinPickListeners.move, { passive:false });
  window.addEventListener('pointerup', ruinPickListeners.up, { passive:false });
  window.addEventListener('pointercancel', ruinPickListeners.cancel, { passive:false });
}

function removeRuinPickListeners(){
  if (!ruinPickListeners.move) return;
  window.removeEventListener('pointermove', ruinPickListeners.move);
  window.removeEventListener('pointerup', ruinPickListeners.up);
  window.removeEventListener('pointercancel', ruinPickListeners.cancel);
  ruinPickListeners.move = null;
  ruinPickListeners.up = null;
  ruinPickListeners.cancel = null;
}

function onRuinPointerDown(e){
  const cardEl = e.currentTarget;

  if (state.gameOver) return;
  if (state.eliminated?.[state.userId]) return;
  if (!ui.effect7Picking) return;
  if (!state.effect7 || state.effect7.playerId !== state.userId || state.effect7.phase !== 'pickRuins') return;

  const slotIndex = Number(cardEl.dataset.i);
  if (!Number.isFinite(slotIndex)) return;

  e7pickDrag.active = true;
  e7pickDrag.slotIndex = slotIndex;
  e7pickDrag.pointerId = e.pointerId;
  e7pickDrag.overHand = false;
  e7pickDrag.sourceEl = cardEl;

  const ghost = createBackGhost();
  document.body.appendChild(ghost);
  e7pickDrag.ghostEl = ghost;

  ghost.style.left = `${e.clientX}px`;
  ghost.style.top  = `${e.clientY}px`;

  cardEl.classList.add('drag-source-hidden');

  setHandDropHint(true);
  setHandDropActive(false);

  addRuinPickListeners();
  e.preventDefault();
}

function onRuinPointerMove(e){
  if (!e7pickDrag.active || e7pickDrag.pointerId !== e.pointerId || !e7pickDrag.ghostEl) return;

  e7pickDrag.ghostEl.style.left = `${e.clientX}px`;
  e7pickDrag.ghostEl.style.top  = `${e.clientY}px`;

  const rect = myHandRow.getBoundingClientRect();
  const over = isPointInRect(e.clientX, e.clientY, rect);
  e7pickDrag.overHand = over;
  setHandDropActive(over);
  e.preventDefault();
}

async function onRuinPointerUp(e){
  if (!e7pickDrag.active || e7pickDrag.pointerId !== e.pointerId) return;

  const slotIndex = e7pickDrag.slotIndex;
  const shouldDrop = e7pickDrag.overHand;
  cleanupE7PickDrag({ keepSourceHidden: shouldDrop });
  removeRuinPickListeners();
  if (shouldDrop) await handleEffect7Pick(slotIndex);
  e.preventDefault();
}

function renderMyHand(){
  const myId = state.userId;
  const handData = state.hands[myId];
  let cards = Array.isArray(handData?.cards) ? handData.cards : [];
  let prevCards = null;
  if (prevMyCardsSig !== null){
    try{
      const parsed = JSON.parse(prevMyCardsSig);
      if (Array.isArray(parsed)) prevCards = parsed;
    } catch {}
  }
  if (ui.effect2DropPending && cards.length === 0 && prevMyCardsSig){
    try{
      const prev = JSON.parse(prevMyCardsSig);
      if (Array.isArray(prev) && prev.length){
        cards = prev;
      }
    } catch {}
  }

  const sig = JSON.stringify(cards);

  let shouldMarkNewLast = false;
  if (prevMyCardsSig !== null){
    try{
      const prev = JSON.parse(prevMyCardsSig);
      if (Array.isArray(prev) && cards.length === prev.length + 1){
        shouldMarkNewLast = true;
      }
    } catch {}
  }

  myHandEl.innerHTML = '';

  cards.forEach((v, i) => {
    const card = document.createElement('div');
    card.className = 'my-card';
    setCardFace(card, v);
    card.dataset.index = String(i);
    if (String(v) === '5') card.classList.add('no-play-pulse');

    if (ui.effect2Selecting && ui.effect2SelectedIndex === i){
      card.classList.add('selected');
    }
    if (ui.effect2Selecting && ui.effect2DropPending && ui.effect2SelectedIndex === i
      && (!prevCards || cards.length >= prevCards.length)){
      card.classList.add('drag-source-hidden');
    }
    if (ui.effect6Selecting && ui.selectedIndex === i){
      card.classList.add('selected');
    }

    if (shouldMarkNewLast && i === cards.length - 1){
      card.classList.add('new-in');
      setTimeout(() => card.classList.remove('new-in'), 350);
    }

    card.addEventListener('pointerdown', onCardPointerDown);
    card.addEventListener('pointermove', onCardPointerMove);
    card.addEventListener('pointerup', onCardPointerUp);
    card.addEventListener('pointercancel', onCardPointerUp);

    myHandEl.appendChild(card);
  });

  prevMyCardsSig = sig;
  updateTurnUI();
}

function renderHands(){
  renderMyIdentity();
  renderMyHand();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  updateDeckUI();
}

async function maybeAutoDrawAtTurnStart(){
  if (!state.roomCode) return;
  if (!state.isMyTurn) return;
  if (autoDrawInFlight) return;
  if (state.turn.drawn) return;
  if (state.turn.paused) return;
  if (state.gameOver) return;
  if (state.eliminated?.[state.userId]) return;

  if (ui.effect2Selecting || ui.effect3Selecting || ui.effect4Selecting || ui.effect6Selecting || ui.effect7Picking || ui.effect7Placing || ui.effect8Selecting || ui.effect8Returning) return;

  autoDrawInFlight = true;
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);
  const myId = state.userId;
  const seq = state.turn.turnSeq;

  try{
    const lockRes = await runTransaction(turnRef, (t) => {
      if (!t) return t;
      if (t.currentPlayerId !== myId) return;
      if (Number(t.turnSeq || 0) !== Number(seq || 0)) return;
      if (t.drawn) return;
      if (t.paused) return;
      return { ...t, drawn:true, drawnBy: myId, drawnAt: Date.now() };
    }, { applyLocally:false });

    if (!lockRes.committed) return;

    const drawn = await drawOneFromDeckAtomic();

    if (!drawn){
      await handleDeckExhausted(myId, seq, null);
      return;
    }

    await emitDrawEvent(myId, seq, 'turn');

    await sleep(DRAW_COMMIT_DELAY_MS);
    await addCardToHandAtomic(myId, drawn);

    await update(turnRef, { paused:false });

  } finally {
    autoDrawInFlight = false;
  }
}

async function drawOneFromDeckAtomic(){
  if (!state.roomCode) return null;
  const deckRef = ref(db, `rooms/${state.roomCode}/deck`);
  let picked = null;

  const res = await runTransaction(deckRef, (deck) => {
    const arr = Array.isArray(deck) ? [...deck] : [];
    if (!arr.length) return arr;
    picked = arr.shift();
    return arr;
  }, { applyLocally:false });

  if (!res.committed) return null;
  return picked;
}

async function addCardToHandAtomic(playerId, cardValue){
  if (!state.roomCode) return;
  const cardsRef = ref(db, `rooms/${state.roomCode}/hands/${playerId}/cards`);
  await runTransaction(cardsRef, (cards) => {
    const arr = Array.isArray(cards) ? [...cards] : [];
    arr.push(cardValue);
    return arr;
  }, { applyLocally:false });
}

async function unshiftCardToDeckAtomic(cardValue){
  if (!state.roomCode) return;
  const deckRef = ref(db, `rooms/${state.roomCode}/deck`);
  await runTransaction(deckRef, (deck) => {
    const arr = Array.isArray(deck) ? [...deck] : [];
    arr.unshift(String(cardValue ?? ''));
    return arr;
  }, { applyLocally:false });
}

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

async function emitDrawEvent(playerId, seq, kind){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/drawEvent`), {
    id,
    playerId,
    seq: Number(seq || 0),
    kind: kind || 'turn',
    at: Date.now()
  });
}

async function emitReturnTopEvent(fromPlayerId){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/returnTopEvent`), {
    id,
    fromPlayerId,
    at: Date.now()
  });
}

async function emitFiveSlideEvent(){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/fiveSlideEvent`), { id, at: Date.now() });
}
async function emitXRevealEvent(mode, targetPlayerId, fromPlayerId, targetCardIndex){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/xRevealEvent`), {
    id,
    mode: mode || 'effect38',
    targetPlayerId: targetPlayerId || null,
    fromPlayerId: fromPlayerId || null,
    targetCardIndex: Number.isFinite(Number(targetCardIndex)) ? Number(targetCardIndex) : null,
    at: Date.now()
  });
}
async function emitOneRevealEvent(targetPlayerId, fromPlayerId, targetCardIndex){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/oneRevealEvent`), {
    id,
    targetPlayerId: targetPlayerId || null,
    fromPlayerId: fromPlayerId || null,
    targetCardIndex: Number.isFinite(Number(targetCardIndex)) ? Number(targetCardIndex) : null,
    at: Date.now()
  });
}

async function emitExplorationFaceEvent(){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/explorationFaceEvent`), { id, at: Date.now() });
}

async function emitExplorationPickEvent({ eventId, rank, playerId, value, sourceType, sourcePlayerId, sourceCardIndex, sourceRuinIndex } = {}){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/explorationPickEvent`), {
    id,
    eventId: eventId || null,
    rank: Number.isFinite(rank) ? rank : null,
    playerId: playerId || null,
    value: value ?? null,
    sourceType: sourceType || null,
    sourcePlayerId: sourcePlayerId || null,
    sourceCardIndex: Number.isFinite(Number(sourceCardIndex)) ? Number(sourceCardIndex) : null,
    sourceRuinIndex: Number.isFinite(Number(sourceRuinIndex)) ? Number(sourceRuinIndex) : null,
    at: Date.now(),
  });
}

function shuffleInPlace(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

async function emitReshuffleEvent(count){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/reshuffleEvent`), {
    id,
    count: Number(count || 0),
    at: Date.now(),
    from: 'played'
  });
}

async function emitRuinMoveEvent(fromPlayerId, cardValue, slotIndex, mode){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/ruinMoveEvent`), {
    id,
    fromPlayerId,
    cardValue: String(cardValue ?? ''),
    slotIndex: Number(slotIndex || 0),
    mode: mode || null,
    at: Date.now()
  });
}

async function emitRuinTakeEvent(toPlayerId, cardValue, slotIndex){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/ruinTakeEvent`), {
    id,
    toPlayerId,
    cardValue: String(cardValue ?? ''),
    slotIndex: Number(slotIndex || 0),
    at: Date.now()
  });
}

async function emitHandTransferEvent(fromPlayerId, toPlayerId, byPlayerId){
  if (!state.roomCode) return;
  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/handTransferEvent`), {
    id,
    fromPlayerId,
    toPlayerId,
    byPlayerId,
    at: Date.now()
  });
}

async function acquireReshuffleLock(){
  if (!state.roomCode) return false;
  const lockRef = ref(db, `rooms/${state.roomCode}/reshuffleLock`);
  const myId = state.userId;

  const res = await runTransaction(lockRef, (v) => {
    if (v && v.by && v.at && (Date.now() - v.at) < 15000) return;
    return { by: myId, at: Date.now() };
  }, { applyLocally:false });

  return !!res.committed;
}

async function releaseReshuffleLock(){
  if (!state.roomCode) return;
  await set(ref(db, `rooms/${state.roomCode}/reshuffleLock`), null);
}

async function reshuffleFromPlayedAndPauseTurn(playerId, seq){
  if (!state.roomCode) return;
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);

  await update(turnRef, { paused:true });

  const locked = await acquireReshuffleLock();
  if (!locked){
    await sleep(RESHUFFLE_ANIM_MS + 40);
    await update(turnRef, { paused:false });
    return;
  }

  try{
    const playedRef = ref(db, `rooms/${state.roomCode}/played`);
    const ps = await get(playedRef);
    const played = ps.val() || {};

    const all = [];
    for (const [pid, arr] of Object.entries(played)){
      if (Array.isArray(arr)){
        arr.forEach(v => { if (v !== undefined && v !== null) all.push(v); });
      }
    }
    const count = all.length;

    if (!count){
      await update(turnRef, { paused:false });
      return;
    }

    await emitReshuffleEvent(count);
    await sleep(RESHUFFLE_ANIM_MS);

    shuffleInPlace(all);

    await Promise.all([
      set(ref(db, `rooms/${state.roomCode}/deck`), all),
      set(ref(db, `rooms/${state.roomCode}/played`), {}),
    ]);

    await update(turnRef, { paused:false });

  } finally {
    await releaseReshuffleLock();
  }
}

async function handleDeckExhausted(playerId, seq, effectKey){
  if (!state.roomCode) return;
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);
  await emitExplorationFaceEvent();

  if (effectKey){
    await set(ref(db, `rooms/${state.roomCode}/${effectKey}`), null);
  }

  await update(turnRef, { paused:true, drawn:true, exhaustedAt: Date.now() });
}

/* anchor取得：自分はplayer-tag、他はplayer-fan */
function getPlayerAnchorEl(playerId){
  return playerCircle.querySelector(`.player-anchor[data-pid="${playerId}"]`);
}

function getPlayerCardAnchorEl(playerId, cardIndex){
  if (!playerId && playerId !== 0) return null;
  if (!Number.isFinite(Number(cardIndex))) return null;
  return playerCircle.querySelector(`.mini-card[data-pid="${playerId}"][data-idx="${cardIndex}"]`);
}

function getPlayerCardRect(playerId, cardIndex){
  if (!Number.isFinite(Number(cardIndex))) return null;
  const idx = Number(cardIndex);
  if (playerId === state.userId){
    const cardEl = myHandEl.querySelector(`.my-card[data-index="${idx}"]`);
    if (!cardEl) return null;
    return cardEl.getBoundingClientRect();
  }
  const cardEl = getPlayerCardAnchorEl(playerId, idx);
  if (!cardEl) return null;
  return cardEl.getBoundingClientRect();
}

function getPlayedRowAnchorEl(playerId){
  if (!playerId && playerId !== 0) return null;
  return playerCircle.querySelector(`.played-row[data-pid="${playerId}"]`);
}

async function animateDrawFromDeckToPlayer(playerId){
  if (!deckPile) return;

  const from = deckPile.getBoundingClientRect();
  const startX = from.left + from.width/2 + 3;
  const startY = from.top  + from.height/2 - 2;

  let endX = startX;
  let endY = startY;

  if (playerId === state.userId){
    const to = myHandEl?.getBoundingClientRect();
    if (to){
      endX = to.right + 16;
      endY = to.top + 18;
    } else {
      endX = startX + 80;
      endY = startY + 80;
    }
  } else {
    const anchor = getPlayerAnchorEl(playerId);
    if (anchor){
      const tr = anchor.getBoundingClientRect();
      endX = tr.left + tr.width/2;
      endY = tr.top + tr.height/2;
    } else {
      const pc = playerCircle.getBoundingClientRect();
      endX = pc.left + pc.width/2;
      endY = pc.top + pc.height/2;
    }
  }

  const flyer = document.createElement('div');
  flyer.className = 'draw-flyer';
  flyer.style.left = `${startX}px`;
  flyer.style.top  = `${startY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-8deg) scale(1)';
  document.body.appendChild(flyer);

  await sleep(0);
  flyer.style.transition = 'transform 130ms ease, top 130ms ease';
  flyer.style.top = `${startY - 18}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-18deg) scale(1.03)';
  await sleep(140);

  flyer.style.transition = 'left 300ms ease, top 300ms ease, transform 300ms ease';
  flyer.style.left = `${endX}px`;
  flyer.style.top  = `${endY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(6deg) scale(1.12)';
  await sleep(320);

  flyer.style.transition = 'opacity 120ms ease, transform 120ms ease';
  flyer.style.opacity = '0';
  flyer.style.transform = 'translate(-50%,-50%) rotate(0deg) scale(0.95)';
  await sleep(140);

  flyer.remove();
}

/* ★②：他プレイヤー視点：その人のアンカー→山札（裏向き） */
async function animateReturnTopFromPlayerAnchorToDeck(playerId){
  if (!deckPile) return;

  const to = deckPile.getBoundingClientRect();
  const endX = to.left + to.width/2;
  const endY = to.top  + to.height/2;

  const anchor = getPlayerAnchorEl(playerId);
  let startX = endX, startY = endY;
  if (anchor){
    const sr = anchor.getBoundingClientRect();
    startX = sr.left + sr.width/2;
    startY = sr.top + sr.height/2;
  } else {
    const pc = playerCircle.getBoundingClientRect();
    startX = pc.left + pc.width/2;
    startY = pc.top + pc.height/2;
  }

  const flyer = document.createElement('div');
  flyer.className = 'back-flyer';
  flyer.style.left = `${startX}px`;
  flyer.style.top  = `${startY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(10deg) scale(1.05)';
  document.body.appendChild(flyer);

  await sleep(0);
  flyer.style.transition = 'transform 120ms ease, top 120ms ease';
  flyer.style.top = `${startY - 16}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(18deg) scale(1.08)';
  await sleep(140);

  flyer.style.transition = 'left 380ms ease, top 380ms ease, transform 380ms ease';
  flyer.style.left = `${endX}px`;
  flyer.style.top  = `${endY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-10deg) scale(0.86)';
  await sleep(400);

  flyer.style.transition = 'opacity 140ms ease, transform 140ms ease';
  flyer.style.opacity = '0';
  flyer.style.transform = 'translate(-50%,-50%) rotate(0deg) scale(0.78)';
  await sleep(160);

  flyer.remove();
}

/* ★②：自分視点：選んだカード(表/数字)→山札 */
async function animateReturnTopFromCardRectToDeck(cardRect, cardValue){
  if (!deckPile || !cardRect) return;

  const to = deckPile.getBoundingClientRect();
  const endX = to.left + to.width/2;
  const endY = to.top  + to.height/2;

  const startX = cardRect.left + cardRect.width/2;
  const startY = cardRect.top  + cardRect.height/2;

  const flyer = createFaceFlyer(cardValue);
  flyer.style.left = `${startX}px`;
  flyer.style.top  = `${startY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-6deg) scale(1.0)';
  document.body.appendChild(flyer);

  await sleep(0);
  flyer.style.transition = 'transform 120ms ease, top 120ms ease';
  flyer.style.top = `${startY - 14}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-14deg) scale(1.06)';
  await sleep(140);

  flyer.style.transition = 'left 380ms ease, top 380ms ease, transform 380ms ease';
  flyer.style.left = `${endX}px`;
  flyer.style.top  = `${endY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(10deg) scale(0.62)';
  await sleep(400);

  flyer.style.transition = 'opacity 140ms ease, transform 140ms ease';
  flyer.style.opacity = '0';
  flyer.style.transform = 'translate(-50%,-50%) rotate(0deg) scale(0.72)';
  await sleep(160);

  flyer.remove();
}

/* ★⑧：他プレイヤー視点：プレイヤー↔プレイヤー（裏向き） */
async function animateBackMoveBetweenPlayers(fromPlayerId, toPlayerId){
  const fromAnchor = getPlayerAnchorEl(fromPlayerId);
  const toAnchor = getPlayerAnchorEl(toPlayerId);

  const pc = playerCircle.getBoundingClientRect();
  let startX = pc.left + pc.width/2;
  let startY = pc.top + pc.height/2;
  let endX = startX;
  let endY = startY;

  if (fromAnchor){
    const fr = fromAnchor.getBoundingClientRect();
    startX = fr.left + fr.width/2;
    startY = fr.top + fr.height/2;
  }
  if (toAnchor){
    const tr = toAnchor.getBoundingClientRect();
    endX = tr.left + tr.width/2;
    endY = tr.top + tr.height/2;
  }

  const flyer = document.createElement('div');
  flyer.className = 'back-flyer';
  flyer.style.left = `${startX}px`;
  flyer.style.top  = `${startY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(10deg) scale(1.05)';
  document.body.appendChild(flyer);

  await sleep(0);
  flyer.style.transition = 'transform 120ms ease, top 120ms ease';
  flyer.style.top = `${startY - 14}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(18deg) scale(1.08)';
  await sleep(140);

  flyer.style.transition = 'left 420ms ease, top 420ms ease, transform 420ms ease';
  flyer.style.left = `${endX}px`;
  flyer.style.top  = `${endY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-10deg) scale(0.9)';
  await sleep(440);

  flyer.style.transition = 'opacity 140ms ease, transform 140ms ease';
  flyer.style.opacity = '0';
  flyer.style.transform = 'translate(-50%,-50%) rotate(0deg) scale(0.82)';
  await sleep(160);

  flyer.remove();
}

/* ★⑧：使用者視点：相手→自分の手札（表向き） */
async function animateMoveFromPlayerToMyHand(fromPlayerId, cardValue){
  const fromAnchor = getPlayerAnchorEl(fromPlayerId);
  const pc = playerCircle.getBoundingClientRect();

  let startX = pc.left + pc.width/2;
  let startY = pc.top + pc.height/2;
  if (fromAnchor){
    const fr = fromAnchor.getBoundingClientRect();
    startX = fr.left + fr.width/2;
    startY = fr.top + fr.height/2;
  }

  const to = myHandEl?.getBoundingClientRect();
  let endX = startX + 120;
  let endY = startY + 120;
  if (to){
    endX = to.left + Math.min(40, to.width * 0.2);
    endY = to.top + 18;
  }

  const flyer = createFaceFlyer(cardValue);
  flyer.style.left = `${startX}px`;
  flyer.style.top  = `${startY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-6deg) scale(0.9)';
  document.body.appendChild(flyer);

  await sleep(0);
  flyer.style.transition = 'transform 120ms ease, top 120ms ease';
  flyer.style.top = `${startY - 12}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-14deg) scale(1.0)';
  await sleep(130);

  flyer.style.transition = 'left 420ms ease, top 420ms ease, transform 420ms ease';
  flyer.style.left = `${endX}px`;
  flyer.style.top  = `${endY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(8deg) scale(1.05)';
  await sleep(440);

  flyer.style.transition = 'opacity 140ms ease, transform 140ms ease';
  flyer.style.opacity = '0';
  flyer.style.transform = 'translate(-50%,-50%) rotate(0deg) scale(0.92)';
  await sleep(160);

  flyer.remove();
}

/* ★全員：5が左→中央へ流れて拡大→右へ流れる（新規書き直し） */
let fiveSlideInFlight = null;
async function animateGlobalFiveSlide(){
  if (fiveSlideInFlight) return fiveSlideInFlight;
  fiveSlideInFlight = new Promise((resolve) => {
    document.querySelectorAll('.global-slide-card.five-slide-anim').forEach((el) => el.remove());

    const card = document.createElement('div');
    card.className = 'global-slide-card five-slide-anim';
    setCardFace(card, '5');
    card.style.animation = `fiveSlideMotion ${FIVE_SLIDE_TOTAL_MS}ms cubic-bezier(.22,.84,.44,1) forwards`;
    document.body.appendChild(card);

    let finished = false;
    const done = () => {
      if (finished) return;
      finished = true;
      card.remove();
      fiveSlideInFlight = null;
      resolve();
    };
    card.addEventListener('animationend', done, { once:true });
    setTimeout(done, FIVE_SLIDE_TOTAL_MS + 200);
  });
  return fiveSlideInFlight;
}

async function triggerFiveSlideSequence(foundByPlayerId){
  if (!state.roomCode) return;
  const shouldEmit = foundByPlayerId ? (state.userId === foundByPlayerId) : state.isHost;
  if (shouldEmit){
    await emitFiveSlideEvent();
  }
  await sleep(FIVE_SLIDE_TOTAL_MS + 80);
}

/* ★全員：✕拡大→下から中央へ */
async function animateGlobalXReveal(mode = 'effect38'){
  globalXBackdrop.classList.remove('hidden');

  const card = document.getElementById('globalXCard');
  if (!card){
    globalXBackdrop.classList.add('hidden');
    return;
  }

  setCardFace(card, 'x');

  card.classList.remove('x-shake', 'x-fall-back');
  card.style.transition = 'none';
  card.style.opacity = '0';
  card.style.transform = (mode === 'effect4') ? 'translateY(0) scale(1.05)' : 'translateY(38vh) scale(0.95)';
  void card.offsetWidth;

  if (mode === 'effect4'){
    card.style.transition = 'opacity 180ms ease';
    card.style.opacity = '1';
    await sleep(220);
    card.classList.add('x-shake');
    await sleep(380);
    card.classList.remove('x-shake');
    card.classList.add('x-fall-back');
    await sleep(1000);
  } else {
    card.style.transition = 'transform 420ms cubic-bezier(.22,.84,.44,1), opacity 220ms ease';
    card.style.opacity = '1';
    card.style.transform = 'translateY(0) scale(1.05)';
    await sleep(460);
    card.classList.add('x-shake');
    await sleep(380);
    card.classList.remove('x-shake');
    card.style.transition = 'opacity 240ms ease, transform 240ms ease';
    card.style.opacity = '0';
    card.style.transform = 'translateY(8px) scale(0.96)';
    await sleep(260);
  }

  card.classList.remove('x-fall-back');
  globalXBackdrop.classList.add('hidden');
}

async function animateEffect4XOwnerReveal(targetPlayerId){
  if (!targetPlayerId) return;
  await sleep(EFFECT4_X_AFTER_CLOSE_DELAY_MS);
  setXRevealHand(targetPlayerId, true);
  await sleep(EFFECT4_X_HAND_REVEAL_MS);
  setXRevealHand(targetPlayerId, false);
  await sleep(EFFECT4_X_HAND_RETURN_MS);
}

async function animateMiniXToDiscard(targetPlayerId, cardIndex){
  if (!targetPlayerId || !Number.isFinite(Number(cardIndex))) return;

  let startX = null;
  let startY = null;
  let endX = null;
  let endY = null;

  if (targetPlayerId === state.userId){
    const cardEl = myHandEl.querySelector(`.my-card[data-index="${cardIndex}"]`);
    if (cardEl){
      const rect = cardEl.getBoundingClientRect();
      startX = rect.left + rect.width / 2;
      startY = rect.top + rect.height / 2;
    }
  } else {
    const cardEl = getPlayerCardAnchorEl(targetPlayerId, cardIndex);
    if (cardEl){
      const rect = cardEl.getBoundingClientRect();
      startX = rect.left + rect.width / 2;
      startY = rect.top + rect.height / 2;
    }
  }

  const rowEl = getPlayedRowAnchorEl(targetPlayerId);
  if (rowEl){
    const rect = rowEl.getBoundingClientRect();
    endX = rect.left + rect.width / 2;
    endY = rect.top + rect.height / 2;
  } else {
    const anchor = getPlayerAnchorEl(targetPlayerId);
    if (anchor){
      const rect = anchor.getBoundingClientRect();
      endX = rect.left + rect.width / 2;
      endY = rect.top + rect.height / 2;
    }
  }

  if (startX == null || startY == null || endX == null || endY == null) return;

  const flyer = createFaceFlyer('x');
  flyer.style.left = `${startX}px`;
  flyer.style.top = `${startY}px`;
  flyer.style.transform = 'translate(-50%,-50%) scale(1.1)';
  document.body.appendChild(flyer);

  await sleep(0);
  flyer.style.transition = 'left 420ms ease, top 420ms ease, transform 420ms ease, opacity 180ms ease';
  flyer.style.left = `${endX}px`;
  flyer.style.top = `${endY}px`;
  flyer.style.transform = 'translate(-50%,-50%) scale(0.72)';
  await sleep(460);

  flyer.style.opacity = '0';
  await sleep(180);
  flyer.remove();
}

/* ★全員：1拡大 */
async function animateGlobalOneReveal(targetPlayerId){
  globalOneBackdrop.classList.remove('hidden');
  setOneRevealHand(targetPlayerId, true);

  const old = document.getElementById('globalOneCard');
  if (old){
    const fresh = old.cloneNode(true);
    old.parentNode.replaceChild(fresh, old);
    setCardFace(fresh, '1');
  }

  await sleep(1500);
  globalOneBackdrop.classList.add('hidden');
  await sleep(1500);
  setOneRevealHand(targetPlayerId, false);
}

/* ★遺跡：スロット中心座標（playerCircle中心基準＝遺跡は固定） */
function getRuinSlotCenterByIndex(slotIndex){
  const idx = Math.max(0, Math.min(5, Number(slotIndex||0)));
  const row = Math.floor(idx / 3);
  const col = idx % 3;

  const pc = playerCircle.getBoundingClientRect();
  const cx = pc.left + pc.width/2;
  const cy = pc.top + pc.height/2;

  const gapX = RUINS_GAP_X;
  const gapY = RUINS_GAP_Y;

  const x = cx + (col - 1) * gapX;
  const y = cy + (row - 0.5) * gapY + RUINS_SHIFT_Y;
  return { x, y };
}

async function waitForRuinCard(slotIndex, timeoutMs = 600){
  const start = Date.now();
  return new Promise((resolve) => {
    const check = () => {
      if (document.querySelector(`.ruins-card[data-i="${slotIndex}"]`)){
        resolve(true);
        return;
      }
      if (Date.now() - start > timeoutMs){
        resolve(false);
        return;
      }
      requestAnimationFrame(check);
    };
    check();
  });
}

/* ★⑦：遺跡→手札（使用者の画面だけ） */
async function animateTakeFromRuinToMyHand(slotIndex, cardValue){
  const { x:startX, y:startY } = getRuinSlotCenterByIndex(slotIndex);

  const to = myHandEl?.getBoundingClientRect();
  let endX = startX + 140;
  let endY = startY + 140;
  if (to){
    endX = to.left + Math.min(40, to.width*0.2);
    endY = to.top + 18;
  }

  const flyer = document.createElement('div');
  flyer.className = 'back-flyer';
  flyer.style.left = `${startX}px`;
  flyer.style.top  = `${startY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(6deg) scale(0.82)';
  document.body.appendChild(flyer);

  await sleep(0);
  flyer.style.transition = 'transform 120ms ease, top 120ms ease';
  flyer.style.top = `${startY - 14}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(14deg) scale(0.90)';
  await sleep(130);

  flyer.style.transition = 'left 420ms ease, top 420ms ease, transform 420ms ease';
  flyer.style.left = `${endX}px`;
  flyer.style.top  = `${endY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-8deg) scale(0.98)';
  await sleep(440);

  flyer.style.transition = 'opacity 140ms ease, transform 140ms ease';
  flyer.style.opacity = '0';
  flyer.style.transform = 'translate(-50%,-50%) rotate(0deg) scale(0.92)';
  await sleep(160);

  flyer.remove();
}

/* ★追加：⑦ 遺跡→手札（他プレイヤー視点） */
async function animateTakeFromRuinToPlayerAnchor(playerId, slotIndex, cardValue){
  const { x:startX, y:startY } = getRuinSlotCenterByIndex(slotIndex);

  let endX = startX + 110;
  let endY = startY - 110;

  const anchor = getPlayerAnchorEl(playerId);
  if (anchor){
    const tr = anchor.getBoundingClientRect();
    endX = tr.left + tr.width/2;
    endY = tr.top + tr.height/2;
  }

  const flyer = document.createElement('div');
  flyer.className = 'back-flyer';
  flyer.style.left = `${startX}px`;
  flyer.style.top  = `${startY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(6deg) scale(0.82)';
  document.body.appendChild(flyer);

  await sleep(0);
  flyer.style.transition = 'transform 120ms ease, top 120ms ease';
  flyer.style.top = `${startY - 14}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(14deg) scale(0.90)';
  await sleep(130);

  flyer.style.transition = 'left 420ms ease, top 420ms ease, transform 420ms ease';
  flyer.style.left = `${endX}px`;
  flyer.style.top  = `${endY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-8deg) scale(0.86)';
  await sleep(440);

  flyer.style.transition = 'opacity 140ms ease, transform 140ms ease';
  flyer.style.opacity = '0';
  flyer.style.transform = 'translate(-50%,-50%) rotate(0deg) scale(0.82)';
  await sleep(160);

  flyer.remove();
}

async function animateMoveFromPlayerToRuin(playerId, cardValue, slotIndex){
  const anchor = getPlayerAnchorEl(playerId);
  let startX, startY;

  if (anchor){
    const sr = anchor.getBoundingClientRect();
    startX = sr.left + sr.width/2;
    startY = sr.top + sr.height/2;
  } else {
    const pc = playerCircle.getBoundingClientRect();
    startX = pc.left + pc.width/2;
    startY = pc.top + pc.height/2;
  }

  const { x:endX, y:endY } = getRuinSlotCenterByIndex(slotIndex);

  const flyer = document.createElement('div');
  flyer.className = 'back-flyer';
  flyer.style.left = `${startX}px`;
  flyer.style.top  = `${startY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-6deg) scale(1)';
  document.body.appendChild(flyer);

  await sleep(0);
  flyer.style.transition = 'transform 120ms ease, top 120ms ease';
  flyer.style.top = `${startY - 18}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-14deg) scale(1.03)';
  await sleep(130);

  flyer.style.transition = 'left 420ms ease, top 420ms ease, transform 420ms ease';
  flyer.style.left = `${endX}px`;
  flyer.style.top  = `${endY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(4deg) scale(0.82)';
  await sleep(440);

  await waitForRuinCard(slotIndex);

  flyer.style.transition = 'opacity 140ms ease, transform 140ms ease';
  flyer.style.opacity = '0';
  flyer.style.transform = 'translate(-50%,-50%) rotate(0deg) scale(0.78)';
  await sleep(160);

  flyer.remove();
}

async function animateOneRevealMoveToRuin(playerId, cardValue, slotIndex){
  const anchor = getPlayerAnchorEl(playerId);
  let startX, startY;

  if (anchor){
    const sr = anchor.getBoundingClientRect();
    startX = sr.left + sr.width/2;
    startY = sr.top + sr.height/2;
  } else {
    const pc = playerCircle.getBoundingClientRect();
    startX = pc.left + pc.width/2;
    startY = pc.top + pc.height/2;
  }

  const { x:endX, y:endY } = getRuinSlotCenterByIndex(slotIndex);

  const flyer = document.createElement('div');
  flyer.className = 'front-flyer face-flyer ruin-reveal-flyer';
  setCardFace(flyer, cardValue);
  flyer.style.left = `${startX}px`;
  flyer.style.top  = `${startY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-6deg) scale(1.1)';
  document.body.appendChild(flyer);

  await sleep(0);
  flyer.style.transition = 'transform 120ms ease, top 120ms ease';
  flyer.style.top = `${startY - 16}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-16deg) scale(1.12)';
  await sleep(140);

  flyer.style.transition = 'left 520ms cubic-bezier(0.22, 1, 0.36, 1), top 520ms cubic-bezier(0.22, 1, 0.36, 1), transform 520ms cubic-bezier(0.22, 1, 0.36, 1)';
  flyer.style.left = `${endX}px`;
  flyer.style.top  = `${endY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(2deg) scale(0.7)';
  await sleep(540);

  flyer.style.transition = 'background 120ms ease, color 120ms ease, opacity 120ms ease';
  flyer.style.backgroundImage = 'var(--card-back-image)';
  flyer.style.backgroundColor = '#fff';
  flyer.style.backgroundSize = 'cover';
  flyer.style.backgroundPosition = 'center';
  flyer.style.color = 'transparent';
  const faceEl = flyer.querySelector('.card-face');
  if (faceEl) faceEl.style.opacity = '0';
  await sleep(140);

  await waitForRuinCard(slotIndex);

  flyer.style.opacity = '0';
  await sleep(120);
  flyer.remove();
}

async function animateXRevealMoveToRuin(playerId, cardIndex, slotIndex){
  let startX, startY;
  const rect = getPlayerCardRect(playerId, cardIndex)
    || (pendingXRevealTarget && pendingXRevealTarget.playerId === playerId && pendingXRevealTarget.rect
      ? pendingXRevealTarget.rect
      : null);

  if (rect){
    startX = rect.left + rect.width / 2;
    startY = rect.top + rect.height / 2;
  } else {
    const anchor = getPlayerAnchorEl(playerId);
    if (anchor){
      const sr = anchor.getBoundingClientRect();
      startX = sr.left + sr.width / 2;
      startY = sr.top + sr.height / 2;
    } else {
      const pc = playerCircle.getBoundingClientRect();
      startX = pc.left + pc.width / 2;
      startY = pc.top + pc.height / 2;
    }
  }

  const { x:endX, y:endY } = getRuinSlotCenterByIndex(slotIndex);

  const flyer = createFaceFlyer('x');
  flyer.style.left = `${startX}px`;
  flyer.style.top = `${startY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-6deg) scale(1.1)';
  document.body.appendChild(flyer);

  await sleep(0);
  flyer.style.transition = 'transform 120ms ease, top 120ms ease';
  flyer.style.top = `${startY - 16}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(-16deg) scale(1.12)';
  await sleep(140);

  flyer.style.transition = 'left 520ms cubic-bezier(0.22, 1, 0.36, 1), top 520ms cubic-bezier(0.22, 1, 0.36, 1), transform 520ms cubic-bezier(0.22, 1, 0.36, 1)';
  flyer.style.left = `${endX}px`;
  flyer.style.top = `${endY}px`;
  flyer.style.transform = 'translate(-50%,-50%) rotate(2deg) scale(0.7)';
  await sleep(540);

  flyer.style.transition = 'background 120ms ease, color 120ms ease, opacity 120ms ease';
  flyer.style.backgroundImage = 'var(--card-back-image)';
  flyer.style.backgroundColor = '#fff';
  flyer.style.backgroundSize = 'cover';
  flyer.style.backgroundPosition = 'center';
  flyer.style.color = 'transparent';
  const faceEl = flyer.querySelector('.card-face');
  if (faceEl) faceEl.style.opacity = '0';
  await sleep(140);

  await waitForRuinCard(slotIndex);

  flyer.style.opacity = '0';
  await sleep(120);
  flyer.remove();

  if (Number.isFinite(Number(cardIndex))){
    setXRevealTargetCard(playerId, cardIndex, false);
  }
  pendingXRevealTarget = null;
}

async function animateReshufflePlayedToDeck(count){
  if (!deckPile) return;

  const dr = deckPile.getBoundingClientRect();
  const deckX = dr.left + dr.width/2;
  const deckY = dr.top + dr.height/2;

  const pc = playerCircle.getBoundingClientRect();
  const centerX = pc.left + pc.width/2;
  const centerY = pc.top + pc.height/2;

  const rows = Array.from(playerCircle.querySelectorAll('.played-row'));
  const starts = rows
    .map(el => el.getBoundingClientRect())
    .filter(r => r.width && r.height);

  const n = Math.min(Math.max(1, Number(count || 0)), 16);
  const flyers = [];

  for (let i=0;i<n;i++){
    const f = document.createElement('div');
    f.className = 'reshuffle-flyer';

    let sx = centerX, sy = centerY;
    if (starts.length){
      const pick = starts[i % starts.length];
      sx = pick.left + pick.width/2 + (((i*13)%18)-9);
      sy = pick.top + pick.height/2 + (((i*9)%14)-7);
    } else {
      sx = centerX + (((i*29)%30)-15);
      sy = centerY + (((i*17)%22)-11);
    }

    f.style.left = `${sx}px`;
    f.style.top  = `${sy}px`;
    f.style.transform = `translate(-50%,-50%) rotate(${((i*13)%18)-9}deg) scale(1)`;
    document.body.appendChild(f);
    flyers.push(f);
  }

  await sleep(20);

  flyers.forEach((f, i) => {
    f.style.transition = 'left 420ms ease, top 420ms ease, transform 420ms ease, opacity 180ms ease';
    f.style.left = `${deckX}px`;
    f.style.top  = `${deckY}px`;
    f.style.transform = `translate(-50%,-50%) rotate(${(i%2?18:-18)}deg) scale(0.55)`;
  });

  await sleep(460);

  flyers.forEach(f => {
    f.style.opacity = '0';
    f.style.transform += ' scale(0.92)';
  });

  deckPile.classList.add('shuffling');
  await sleep(560);

  flyers.forEach(f => f.remove());
  deckPile.classList.remove('shuffling');
}

/* =========================
   プレイ処理
   ========================= */
async function playCardFromHand(cardIndex){
  if (!state.roomCode) return;
  if (!state.isPlayable) return;
  if (state.gameOver) return;
  if (state.eliminated?.[state.userId]) return;

  const myId = state.userId;
  const handData = state.hands[myId];
  const cards = Array.isArray(handData?.cards) ? [...handData.cards] : [];
  if (cardIndex < 0 || cardIndex >= cards.length) return;

  const used = cards.splice(cardIndex, 1)[0];

  await update(ref(db, `rooms/${state.roomCode}/hands/${myId}`), { cards });

  const playedRef = ref(db, `rooms/${state.roomCode}/played/${myId}`);
  await runTransaction(playedRef, (arr) => {
    const a = Array.isArray(arr) ? [...arr] : [];
    a.push(used);
    return a;
  }, { applyLocally:false });

  if (String(used) === '2'){
    await resolveEffect2(myId);
    return;
  }
  if (String(used) === '3'){
    await resolveEffect3(myId);
    return;
  }
  if (String(used) === '4'){
    await resolveEffect4(myId);
    return;
  }
  if (String(used) === '6'){
    await resolveEffect6(myId);
    return;
  }
  if (String(used) === '7'){
    await resolveEffect7(myId);
    return;
  }
  if (String(used) === '8'){
    await resolveEffect8(myId);
    return;
  }
  if (String(used) === '1'){
    await advanceTurnToNextPlayer();
    return;
  }

  await resolveCardEffectPlaceholder(used);
  await advanceTurnToNextPlayer();
}

async function resolveCardEffectPlaceholder(usedCard){
  await new Promise(r => setTimeout(r, 250));
  console.log('EFFECT (placeholder):', usedCard);
}

async function removeCardFromHandByIndex(playerId, cardIndex){
  if (!state.roomCode) return null;
  const cardsRef = ref(db, `rooms/${state.roomCode}/hands/${playerId}/cards`);
  let removedValue = null;
  const res = await runTransaction(cardsRef, (cs) => {
    const arr = Array.isArray(cs) ? [...cs] : [];
    const idx = Math.max(0, Math.min(arr.length - 1, Number(cardIndex)));
    if (!arr.length || idx < 0 || idx >= arr.length) return arr;
    removedValue = arr.splice(idx, 1)[0];
    return arr;
  }, { applyLocally:false });

  if (!res.committed) return null;
  return removedValue;
}

async function addCardToPlayed(playerId, cardValue){
  if (!state.roomCode) return;
  const pRef = ref(db, `rooms/${state.roomCode}/played/${playerId}`);
  await runTransaction(pRef, (arr) => {
    const a = Array.isArray(arr) ? [...arr] : [];
    a.push(String(cardValue ?? ''));
    return a;
  }, { applyLocally:false });
}

async function placeCardIntoRuins(playerId, cardValue, { skipEvent = false, eventMode = null } = {}){
  if (!state.roomCode) return null;
  const ruinsRef = ref(db, `rooms/${state.roomCode}/ruins`);
  let slotIndex = null;
  const res = await runTransaction(ruinsRef, (ruins) => {
    const slots = Array.isArray(ruins) ? [...ruins] : [];
    for (let i=0;i<6;i++){
      if (slots[i] === undefined) slots[i] = null;
    }
    for (let i=0;i<6;i++){
      if (!slots[i]){
        slotIndex = i;
        slots[i] = { v: String(cardValue ?? ''), by: playerId, at: Date.now() };
        break;
      }
    }
    return slots;
  }, { applyLocally:false });

  if (res.committed && slotIndex !== null){
    if (!skipEvent){
      await emitRuinMoveEvent(playerId, cardValue, slotIndex, eventMode);
    }
  }

  return slotIndex;
}

async function clearEffectsForOneReveal(){
  if (!state.roomCode) return;
  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/effect3`), null),
    set(ref(db, `rooms/${state.roomCode}/effect4`), null),
    set(ref(db, `rooms/${state.roomCode}/effect8`), null),
  ]);
}

async function clearEffectsForXReveal(){
  if (!state.roomCode) return;
  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/effect3`), null),
    set(ref(db, `rooms/${state.roomCode}/effect8`), null),
  ]);
}

async function resolveOneReveal(targetPlayerId, cardIndex, removedValue, revealingPlayerId){
  if (!state.roomCode || !targetPlayerId) return;

  hidePeekCard();
  hideConfirmPop();

  await clearEffectsForOneReveal();
  await emitOneRevealEvent(targetPlayerId, revealingPlayerId || null, cardIndex);
  await sleep(3000);

  let value = removedValue;
  if (value == null){
    value = await removeCardFromHandByIndex(targetPlayerId, cardIndex);
  }
  if (value != null){
    const slotsNow = getRuinsSlots();
    const slotIndex = firstEmptyRuinSlotIndex(slotsNow);
    if (slotIndex !== null){
      await emitRuinMoveEvent(targetPlayerId, value, slotIndex, 'oneReveal');
      await sleep(RUIN_MOVE_ANIM_MS);
      const ruinsRef = ref(db, `rooms/${state.roomCode}/ruins`);
      await runTransaction(ruinsRef, (ruins) => {
        const src = Array.isArray(ruins) ? [...ruins] : [];
        const slots = new Array(6).fill(null);
        for (let i=0;i<6;i++) slots[i] = (src[i] === undefined ? null : src[i]);
        if (slots[slotIndex]) return slots;
        slots[slotIndex] = { v: String(value), by: targetPlayerId, at: Date.now() };
        return slots;
      }, { applyLocally:false });
    }
  }

  await set(ref(db, `rooms/${state.roomCode}/eliminated/${targetPlayerId}`), true);
  state.eliminated = { ...(state.eliminated || {}), [targetPlayerId]: true };
  await update(ref(db, `rooms/${state.roomCode}/turn`), { paused:false });
  await advanceTurnToNextPlayer();
}

async function moveAllCardsToPlayer(fromPlayerId, toPlayerId){
  if (!state.roomCode || !fromPlayerId || !toPlayerId) return [];
  if (fromPlayerId === toPlayerId) return [];

  const fromRef = ref(db, `rooms/${state.roomCode}/hands/${fromPlayerId}/cards`);
  let moved = [];
  const res = await runTransaction(fromRef, (cards) => {
    const arr = Array.isArray(cards) ? [...cards] : [];
    moved = arr.map(v => String(v));
    return [];
  }, { applyLocally:false });

  if (!res.committed || !moved.length) return [];

  const toRef = ref(db, `rooms/${state.roomCode}/hands/${toPlayerId}/cards`);
  await runTransaction(toRef, (cards) => {
    const arr = Array.isArray(cards) ? [...cards] : [];
    return arr.concat(moved);
  }, { applyLocally:false });

  return moved;
}

async function discardHandToPlayed(playerId){
  if (!state.roomCode || !playerId) return [];

  const handRef = ref(db, `rooms/${state.roomCode}/hands/${playerId}/cards`);
  let removed = [];
  const res = await runTransaction(handRef, (cards) => {
    const arr = Array.isArray(cards) ? [...cards] : [];
    removed = arr.map(v => String(v));
    return [];
  }, { applyLocally:false });

  if (!res.committed || !removed.length) return [];

  const playedRef = ref(db, `rooms/${state.roomCode}/played/${playerId}`);
  await runTransaction(playedRef, (arr) => {
    const a = Array.isArray(arr) ? [...arr] : [];
    return a.concat(removed);
  }, { applyLocally:false });

  return removed;
}

async function resolveXReveal(targetPlayerId, cardIndex, removedValue, revealingPlayerId){
  if (!state.roomCode || !targetPlayerId) return;

  hidePeekCard();
  hideConfirmPop();

  await clearEffectsForXReveal();
  await emitXRevealEvent('effect38', targetPlayerId, revealingPlayerId || null, cardIndex);

  await sleep(3000);
  let value = removedValue;
  if (value == null){
    value = await removeCardFromHandByIndex(targetPlayerId, cardIndex);
  }
  if (value != null){
    await addCardToPlayed(targetPlayerId, value);
  }

  if (revealingPlayerId){
    await sleep(1500);
    await emitHandTransferEvent(revealingPlayerId, targetPlayerId, null);
    await moveAllCardsToPlayer(revealingPlayerId, targetPlayerId);
    await set(ref(db, `rooms/${state.roomCode}/eliminated/${revealingPlayerId}`), true);
    state.eliminated = { ...(state.eliminated || {}), [revealingPlayerId]: true };
  }

  await update(ref(db, `rooms/${state.roomCode}/turn`), { paused:false });
  await advanceTurnToNextPlayer();
}

async function resolveEffect4XReveal(targetPlayerId, cardIndex){
  if (!state.roomCode || !targetPlayerId) return;

  hidePeekCard();
  hideConfirmPop();

  await emitXRevealEvent('effect4', targetPlayerId, state.userId, cardIndex);
  await sleep(XRAY_MINI_DELAY_MS + EFFECT4_X_GLOBAL_MS + XRAY_MINI_DELAY_MS);

  const value = await removeCardFromHandByIndex(targetPlayerId, cardIndex);
  if (value != null){
    const slotsNow = getRuinsSlots();
    const slotIndex = firstEmptyRuinSlotIndex(slotsNow);
    if (slotIndex !== null){
      await emitRuinMoveEvent(targetPlayerId, value, slotIndex, 'xReveal');
      await sleep(RUIN_MOVE_ANIM_MS);
      const ruinsRef = ref(db, `rooms/${state.roomCode}/ruins`);
      await runTransaction(ruinsRef, (ruins) => {
        const src = Array.isArray(ruins) ? [...ruins] : [];
        const slots = new Array(6).fill(null);
        for (let i=0;i<6;i++) slots[i] = (src[i] === undefined ? null : src[i]);
        if (slots[slotIndex]) return slots;
        slots[slotIndex] = { v: String(value), by: targetPlayerId, at: Date.now() };
        return slots;
      }, { applyLocally:false });
    }
  }

  await set(ref(db, `rooms/${state.roomCode}/eliminated/${targetPlayerId}`), true);
  state.eliminated = { ...(state.eliminated || {}), [targetPlayerId]: true };

  await set(ref(db, `rooms/${state.roomCode}/effect4`), null);
  await update(ref(db, `rooms/${state.roomCode}/turn`), { paused:false });
  await advanceTurnToNextPlayer();
}

/* =========================
   ★②：追加ドロー（全員に裏で可視）
      → 手札全て大小
      → 1枚クリックで青枠
      → 山札TOPへ戻す（全員に裏で可視）
   ========================= */
async function resolveEffect2(playerId){
  if (!state.roomCode) return;
  const seq = state.turn.turnSeq;
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);

  await update(turnRef, { paused:true });

  const effectId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/effect2`), {
    id: effectId,
    playerId,
    seq: Number(seq || 0),
    phase: 'draw',
    at: Date.now()
  });

  const drawn = await drawOneFromDeckAtomic();
  if (!drawn){
    await handleDeckExhausted(playerId, seq, 'effect2');
    return;
  }

  // 全員に裏で「山札→その人」移動アニメ
  await emitDrawEvent(playerId, seq, 'effect2');
  await sleep(DRAW_COMMIT_DELAY_MS);
  await addCardToHandAtomic(playerId, drawn);

  // 手札全て大小＆クリック選択へ
  await set(ref(db, `rooms/${state.roomCode}/effect2`), {
    id: effectId,
    playerId,
    seq: Number(seq || 0),
    phase: 'select',
    at: Date.now()
  });
}

/* ★②：手札から1枚選んで山札TOPへ戻す（修正版：選んだカード位置→山札へ飛ぶ） */
async function handleEffect2Pick(cardIndex, cardEl){
  if (!state.roomCode) return;

  const ef = state.effect2;
  if (!ef || ef.playerId !== state.userId || ef.phase !== 'select'){
    ui.effect2DropPending = false;
    renderMyHand();
    return;
  }

  const myId = state.userId;

  // ★重要：先に「クリックしたカードのrect」を確保（再描画でDOMが消える前）
  let fixedRect = null;
  if (cardEl && cardEl.getBoundingClientRect){
    const r = cardEl.getBoundingClientRect();
    fixedRect = { left:r.left, top:r.top, width:r.width, height:r.height };
  }

  // クリックしたカードを青枠に（少し見せる）
  ui.effect2SelectedIndex = cardIndex;
  ui.effect2DropPending = true;
  if (cardEl){
    cardEl.classList.add('selected');
    await sleep(60);
    cardEl.classList.add('drag-source-hidden');
  }

  // DBからそのカードを抜く（値を取得）
  const cardsRef = ref(db, `rooms/${state.roomCode}/hands/${myId}/cards`);
  let pickedValue = null;

  const rem = await runTransaction(cardsRef, (cards) => {
    const arr = Array.isArray(cards) ? [...cards] : [];
    if (cardIndex < 0 || cardIndex >= arr.length) return arr;
    pickedValue = arr.splice(cardIndex, 1)[0];
    return arr;
  }, { applyLocally:false });

  if (!rem.committed || pickedValue === null || pickedValue === undefined){
    ui.effect2DropPending = false;
    renderMyHand();
    return;
  }

  if (!fixedRect){
    const hr = myHandEl?.getBoundingClientRect?.();
    if (hr){
      fixedRect = { left: hr.left + hr.width*0.5, top: hr.top + hr.height*0.5, width: 60, height: 90 };
    }
  }

  // 自分：移動アニメなし（他プレイヤーは裏アニメのみ）
  // await animateReturnTopFromCardRectToDeck(fixedRect, pickedValue);

  // 他プレイヤー：裏で「その人→山札」アニメ（イベント）
  await emitReturnTopEvent(myId);

  // 山札の一番上へ戻す（unshift）
  await unshiftCardToDeckAtomic(pickedValue);

  // effect2終了
  await set(ref(db, `rooms/${state.roomCode}/effect2`), null);

  ui.effect2Selecting = false;
  ui.effect2SelectedIndex = null;
  ui.effect2DropPending = false;
  updateTurnUI();
  renderMyHand();

  await update(ref(db, `rooms/${state.roomCode}/turn`), { paused:false });
  await advanceTurnToNextPlayer();
}

/* =========================
   ★③：他プレイヤー扇カード大小 → 1枚選んで使用者だけ拡大
       他は使用者→対象へ点線矢印
       下ポップ「閉じてもいいですか」→はいで次ターン
       ※見たカードが5なら全員：左→中央で停止→右、ゲーム終了、全員停止
   ========================= */
async function resolveEffect3(playerId){
  if (!state.roomCode) return;
  const seq = state.turn.turnSeq;
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);

  await update(turnRef, { paused:true });

  const effectId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/effect3`), {
    id: effectId,
    playerId,
    seq: Number(seq || 0),
    phase: 'select',
    at: Date.now(),
    targetPlayerId: null,
    targetCardIndex: null,
    revealed: null
  });
}

async function handleEffect3Pick(targetPlayerId, cardIndex){
  if (!state.roomCode) return;
  const ef = state.effect3;
  if (!ef || ef.playerId !== state.userId || ef.phase !== 'select') return;
  if (!targetPlayerId || targetPlayerId === state.userId) return;

  const hand = state.hands?.[targetPlayerId];
  const cards = Array.isArray(hand?.cards) ? hand.cards : [];
  if (!cards.length) return;

  const idx = Math.max(0, Math.min(cards.length - 1, Number(cardIndex||0)));
  const revealed = String(cards[idx] ?? '');

  if (revealed === '1'){
    await resolveOneReveal(targetPlayerId, idx, null, state.userId);
    return;
  }

  if (revealed === 'x' || revealed === '✕'){
    await resolveXReveal(targetPlayerId, idx, null, state.userId);
    return;
  }

  // まずDBへ確定（矢印のため target を残す）
  await set(ref(db, `rooms/${state.roomCode}/effect3`), {
    id: ef.id,
    playerId: ef.playerId,
    seq: Number(ef.seq || 0),
    phase: 'confirm',
    at: Date.now(),
    targetPlayerId,
    targetCardIndex: idx,
    revealed
  });

  // ★見たカードが5なら：通常拡大表示なし → 全員演出 → ゲーム終了（全員停止）
  if (revealed === '5'){
    // 使用者側も拡大を出さない
    hidePeekCard();
    hideConfirmPop();

    await sleep(FIVE_ARROW_DELAY_MS);
    await triggerFiveSlideSequence(ef.playerId);
    if (!state.gameOver){
      await setGameOverFoundFive(ef.playerId);
    }

    // effect3は残しても良いが、以後の操作不要なので消す
    await set(ref(db, `rooms/${state.roomCode}/effect3`), null);
  }
}

async function finishEffect3AndAdvance(){
  if (!state.roomCode) return;
  if (state.gameOver) return;

  const ef = state.effect3;
  if (!ef || ef.playerId !== state.userId) return;

  hidePeekCard();

  await set(ref(db, `rooms/${state.roomCode}/effect3`), null);
  await update(ref(db, `rooms/${state.roomCode}/turn`), { paused:false });

  await advanceTurnToNextPlayer();
}

/* =========================
   ★④：他プレイヤー扇カード大小 → 1枚選んで使用者だけ拡大
       他は使用者→対象へ点線矢印
       下ポップ→はいで次ターン
   ========================= */
async function resolveEffect4(playerId){
  if (!state.roomCode) return;
  const seq = state.turn.turnSeq;
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);

  await update(turnRef, { paused:true });

  const effectId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/effect4`), {
    id: effectId,
    playerId,
    seq: Number(seq || 0),
    phase: 'select',
    at: Date.now(),
    targetPlayerId: null,
    targetCardIndex: null,
    revealed: null
  });
}

async function handleEffect4Pick(targetPlayerId, cardIndex){
  if (!state.roomCode) return;
  const ef = state.effect4;
  if (!ef || ef.playerId !== state.userId || ef.phase !== 'select') return;
  if (!targetPlayerId || targetPlayerId === state.userId) return;

  const hand = state.hands?.[targetPlayerId];
  const cards = Array.isArray(hand?.cards) ? hand.cards : [];
  if (!cards.length) return;

  const idx = Math.max(0, Math.min(cards.length - 1, Number(cardIndex||0)));
  const revealed = String(cards[idx] ?? '');

  if (revealed === '1'){
    await resolveOneReveal(targetPlayerId, idx, null, state.userId);
    return;
  }

  if (revealed === 'x' || revealed === '✕'){
    await set(ref(db, `rooms/${state.roomCode}/effect4`), {
      id: ef.id,
      playerId: ef.playerId,
      seq: Number(ef.seq || 0),
      phase: 'confirm',
      at: Date.now(),
      targetPlayerId,
      targetCardIndex: idx,
      revealed
    });
    await resolveEffect4XReveal(targetPlayerId, idx);
    return;
  }

  // DBへ確定
  await set(ref(db, `rooms/${state.roomCode}/effect4`), {
    id: ef.id,
    playerId: ef.playerId,
    seq: Number(ef.seq || 0),
    phase: 'confirm',
    at: Date.now(),
    targetPlayerId,
    targetCardIndex: idx,
    revealed
  });
}

async function finishEffect4AndAdvance(){
  if (!state.roomCode) return;
  if (state.gameOver) return;

  const ef = state.effect4;
  if (!ef || ef.playerId !== state.userId) return;

  hidePeekCard();

  await set(ref(db, `rooms/${state.roomCode}/effect4`), null);
  await update(ref(db, `rooms/${state.roomCode}/turn`), { paused:false });

  await advanceTurnToNextPlayer();
}

/* ⑥：追加ドロー → 手札大小 → 1枚をドラッグで遺跡へ */
async function resolveEffect6(playerId){
  if (!state.roomCode) return;
  const seq = state.turn.turnSeq;
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);

  await update(turnRef, { paused:true });

  const effectId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/effect6`), {
    id: effectId,
    playerId,
    seq: Number(seq || 0),
    phase: 'draw',
    at: Date.now()
  });

  const drawn = await drawOneFromDeckAtomic();
  if (!drawn){
    await handleDeckExhausted(playerId, seq, 'effect6');
    return;
  }

  await emitDrawEvent(playerId, seq, 'effect6');
  await sleep(DRAW_COMMIT_DELAY_MS);
  await addCardToHandAtomic(playerId, drawn);

  await set(ref(db, `rooms/${state.roomCode}/effect6`), {
    id: effectId,
    playerId,
    seq: Number(seq || 0),
    phase: 'select',
    at: Date.now()
  });
}

async function handleEffect6Drop(cardIndex){
  if (!state.roomCode) return;

  const ef = state.effect6;
  if (!ef || ef.playerId !== state.userId || ef.phase !== 'select') return;

  const slotsNow = getRuinsSlots();
  const slotIndex = firstEmptyRuinSlotIndex(slotsNow);
  if (slotIndex === null) return;

  const myId = state.userId;
  const cardsRef = ref(db, `rooms/${state.roomCode}/hands/${myId}/cards`);
  let removedValue = null;

  const rem = await runTransaction(cardsRef, (cards) => {
    const arr = Array.isArray(cards) ? [...cards] : [];
    if (cardIndex < 0 || cardIndex >= arr.length) return arr;
    removedValue = arr.splice(cardIndex, 1)[0];
    return arr;
  }, { applyLocally:false });

  if (!rem.committed || removedValue === null || removedValue === undefined){
    return;
  }

  const localSlots = getRuinsSlots();
  if (Number.isFinite(slotIndex) && slotIndex >= 0 && slotIndex < localSlots.length){
    localSlots[slotIndex] = { v: String(removedValue), by: myId, at: Date.now() };
    state.ruins = localSlots;
    renderHands();
  }

  await emitRuinMoveEvent(myId, removedValue, slotIndex);
  await sleep(RUIN_MOVE_ANIM_MS);

  const ruinsRef = ref(db, `rooms/${state.roomCode}/ruins`);
  await runTransaction(ruinsRef, (ruins) => {
    const src = Array.isArray(ruins) ? [...ruins] : [];
    const slots = new Array(6).fill(null);
    for (let i=0;i<6;i++) slots[i] = (src[i] === undefined ? null : src[i]);
    if (slots[slotIndex]) return slots;
    slots[slotIndex] = { v: String(removedValue), by: myId, at: Date.now() };
    return slots;
  }, { applyLocally:false });

  await set(ref(db, `rooms/${state.roomCode}/effect6`), null);

  ui.effect6Selecting = false;
  ui.selectedIndex = null;
  updateTurnUI();
  renderMyHand();

  await update(ref(db, `rooms/${state.roomCode}/turn`), { paused:false });
  await advanceTurnToNextPlayer();
}

/* =========================
   ⑦：遺跡→手札→手札→遺跡
   ========================= */
async function resolveEffect7(playerId){
  if (!state.roomCode) return;
  const seq = state.turn.turnSeq;
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);

  const ruinsSlots = getRuinsSlots();
  const hasRuins = ruinsSlots.some((slot) => !!slot);
  if (!hasRuins){
    await advanceTurnToNextPlayer();
    return;
  }

  await update(turnRef, { paused:true });

  const effectId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/effect7`), {
    id: effectId,
    playerId,
    seq: Number(seq || 0),
    phase: 'pickRuins',
    at: Date.now(),
    targetSlotIndex: null,
    pickedValue: null
  });
}

async function handleEffect7Pick(slotIndex){
  if (!state.roomCode) return;

  const ef = state.effect7;
  if (!ef || ef.playerId !== state.userId || ef.phase !== 'pickRuins') return;

  const ruinsRef = ref(db, `rooms/${state.roomCode}/ruins`);
  const myId = state.userId;

  let pickedObj = null;

  const res = await runTransaction(ruinsRef, (ruins) => {
    const src = Array.isArray(ruins) ? [...ruins] : [];
    const slots = new Array(6).fill(null);
    for (let i=0;i<6;i++) slots[i] = (src[i] === undefined ? null : src[i]);

    const idx = Number(slotIndex);
    if (!Number.isFinite(idx) || idx < 0 || idx > 5) return slots;
    if (!slots[idx]) return slots;

    pickedObj = slots[idx];
    slots[idx] = null;
    return slots;
  }, { applyLocally:false });

  if (!res.committed || !pickedObj) return;

  const cardValue = String(pickedObj?.v ?? '');

  const localSlots = getRuinsSlots();
  if (Number.isFinite(slotIndex) && slotIndex >= 0 && slotIndex < localSlots.length){
    localSlots[slotIndex] = null;
    state.ruins = localSlots;
    renderHands();
  }

  await emitRuinTakeEvent(myId, cardValue, slotIndex);
  await addCardToHandAtomic(myId, cardValue);

  await set(ref(db, `rooms/${state.roomCode}/effect7`), {
    id: ef.id,
    playerId: myId,
    seq: Number(ef.seq || 0),
    phase: 'placeBack',
    at: Date.now(),
    targetSlotIndex: Number(slotIndex),
    pickedValue: cardValue
  });

  updateTurnUI();
}

async function handleEffect7Drop(cardIndex){
  if (!state.roomCode) return;

  const ef = state.effect7;
  if (!ef || ef.playerId !== state.userId || ef.phase !== 'placeBack') return;

  const slotIndex = Number(ef.targetSlotIndex);
  if (!Number.isFinite(slotIndex) || slotIndex < 0 || slotIndex > 5) return;

  const myId = state.userId;
  const cardsRef = ref(db, `rooms/${state.roomCode}/hands/${myId}/cards`);
  let removedValue = null;

  const rem = await runTransaction(cardsRef, (cards) => {
    const arr = Array.isArray(cards) ? [...cards] : [];
    if (cardIndex < 0 || cardIndex >= arr.length) return arr;
    removedValue = arr.splice(cardIndex, 1)[0];
    return arr;
  }, { applyLocally:false });

  if (!rem.committed || removedValue == null) return;

  const localSlots = getRuinsSlots();
  if (Number.isFinite(slotIndex) && slotIndex >= 0 && slotIndex < localSlots.length){
    localSlots[slotIndex] = { v: String(removedValue), by: myId, at: Date.now() };
    state.ruins = localSlots;
    renderHands();
  }

  await emitRuinMoveEvent(myId, removedValue, slotIndex);
  await sleep(RUIN_MOVE_ANIM_MS);

  const ruinsRef = ref(db, `rooms/${state.roomCode}/ruins`);
  await runTransaction(ruinsRef, (ruins) => {
    const src = Array.isArray(ruins) ? [...ruins] : [];
    const slots = new Array(6).fill(null);
    for (let i=0;i<6;i++) slots[i] = (src[i] === undefined ? null : src[i]);

    if (slots[slotIndex]) return slots;

    slots[slotIndex] = { v: String(removedValue), by: myId, at: Date.now() };
    return slots;
  }, { applyLocally:false });

  await set(ref(db, `rooms/${state.roomCode}/effect7`), null);

  ui.effect7Picking = false;
  ui.effect7Placing = false;
  ui.effect7TargetSlot = null;
  ui.effect7PickedValue = null;
  updateTurnUI();
  renderMyHand();

  await update(ref(db, `rooms/${state.roomCode}/turn`), { paused:false });
  await advanceTurnToNextPlayer();
}

/* =========================
   ⑧：相手の手札を1枚 → 自分の手札へ → その相手に1枚返す
   ========================= */
async function resolveEffect8(playerId){
  if (!state.roomCode) return;
  const seq = state.turn.turnSeq;
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);

  await update(turnRef, { paused:true });

  const effectId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  await set(ref(db, `rooms/${state.roomCode}/effect8`), {
    id: effectId,
    playerId,
    seq: Number(seq || 0),
    phase: 'select',
    at: Date.now(),
    targetPlayerId: null,
    targetCardIndex: null,
    pickedValue: null
  });
}

async function handleEffect8Pick(targetPlayerId, cardIndex){
  if (!state.roomCode) return;
  const ef = state.effect8;
  if (!ef || ef.playerId !== state.userId || ef.phase !== 'select') return;
  if (!targetPlayerId || targetPlayerId === state.userId) return;

  const hand = state.hands?.[targetPlayerId];
  const cards = Array.isArray(hand?.cards) ? hand.cards : [];
  if (!cards.length) return;

  const idx = Math.max(0, Math.min(cards.length - 1, Number(cardIndex || 0)));
  const revealed = String(cards[idx] ?? '');

  if (revealed === '1'){
    await resolveOneReveal(targetPlayerId, idx, null, state.userId);
    return;
  }
  if (revealed === 'x' || revealed === '✕'){
    await resolveXReveal(targetPlayerId, idx, null, state.userId);
    return;
  }

  const cardsRef = ref(db, `rooms/${state.roomCode}/hands/${targetPlayerId}/cards`);
  let removedValue = null;

  const rem = await runTransaction(cardsRef, (cs) => {
    const arr = Array.isArray(cs) ? [...cs] : [];
    if (idx < 0 || idx >= arr.length) return arr;
    removedValue = arr.splice(idx, 1)[0];
    return arr;
  }, { applyLocally:false });

  if (!rem.committed || removedValue == null) return;

  await emitHandTransferEvent(targetPlayerId, state.userId, state.userId);
  await animateMoveFromPlayerToMyHand(targetPlayerId, removedValue);
  await addCardToHandAtomic(state.userId, String(removedValue));

  await set(ref(db, `rooms/${state.roomCode}/effect8`), {
    id: ef.id,
    playerId: ef.playerId,
    seq: Number(ef.seq || 0),
    phase: 'return',
    at: Date.now(),
    targetPlayerId,
    targetCardIndex: idx,
    pickedValue: String(removedValue)
  });

  updateTurnUI();
}

async function handleEffect8Drop(cardIndex){
  if (!state.roomCode) return;
  const ef = state.effect8;
  if (!ef || ef.playerId !== state.userId || ef.phase !== 'return') return;

  const targetPlayerId = ef.targetPlayerId;
  if (!targetPlayerId) return;

  const myId = state.userId;
  const cardsRef = ref(db, `rooms/${state.roomCode}/hands/${myId}/cards`);
  let removedValue = null;

  const rem = await runTransaction(cardsRef, (cards) => {
    const arr = Array.isArray(cards) ? [...cards] : [];
    if (cardIndex < 0 || cardIndex >= arr.length) return arr;
    removedValue = arr.splice(cardIndex, 1)[0];
    return arr;
  }, { applyLocally:false });

  if (!rem.committed || removedValue == null) return;

  await emitHandTransferEvent(myId, targetPlayerId, myId);
  await addCardToHandAtomic(targetPlayerId, String(removedValue));

  await set(ref(db, `rooms/${state.roomCode}/effect8`), null);

  ui.effect8Selecting = false;
  ui.effect8Returning = false;
  ui.effect8TargetPlayerId = null;
  updateTurnUI();
  renderMyHand();

  await update(ref(db, `rooms/${state.roomCode}/turn`), { paused:false });
  await advanceTurnToNextPlayer();
}

async function getSeatedPlayers(){
  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  return Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? { seatIndex:Number(seatIndex), id:t.playerId, name:t.playerName||'名無し' } : null))
    .filter(Boolean)
    .sort((a,b) => a.seatIndex - b.seatIndex);
}

async function advanceTurnToNextPlayer(){
  if (!state.roomCode) return;
  if (state.gameOver) return;

  const players = await getSeatedPlayers();
  if (!players.length){
    renderEffectArrowLayer([]);
    return;
  }

  const alive = players.filter(p => !state.eliminated?.[p.id]);
  if (!alive.length) return;

  const currentId = state.turn.currentPlayerId || alive[0].id;
  let next = alive[0];
  const idxAll = players.findIndex(p => p.id === currentId);
  if (idxAll >= 0){
    for (let offset = 1; offset <= players.length; offset += 1){
      const candidate = players[(idxAll + offset) % players.length];
      if (!state.eliminated?.[candidate.id]){
        next = candidate;
        break;
      }
    }
  }

  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);
  const tSnap = await get(turnRef);
  const t = tSnap.val() || {};
  const nextSeq = Number(t.turnSeq || 0) + 1;

  await set(turnRef, { currentPlayerId: next.id, turnSeq: nextSeq, drawn:false, paused:false, updatedAt: Date.now() });
}

const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribePlayed();
  subscribeDeck();
  subscribeRuins();

  subscribeEliminated();
  subscribeGameOver();

  subscribeEffect2();
  subscribeEffect3();
  subscribeEffect4();
  subscribeEffect6();
  subscribeEffect7();
  subscribeEffect8();

  subscribeTurn();
  subscribeDrawEvent();
  subscribeReturnTopEvent();
  subscribeReshuffleEvent();
  subscribeRuinMoveEvent();
  subscribeRuinTakeEvent();
  subscribeHandTransferEvent();

  subscribeFiveSlideEvent();
  subscribeXRevealEvent();
  subscribeOneRevealEvent();
  subscribeExplorationFaceEvent();

  window.addEventListener('resize', () => {
    updateDeckPosition();
    renderEffectArrowLayer(latestPlayers || []);
  });

  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;
  if (!state.isHost && !maxPlayers){ seatPop.classList.add('hidden'); return; }
  if (state.seatedTable !== null){ seatPop.classList.add('hidden'); return; }

  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try{
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;
        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });
          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';
    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => { seatPop.classList.add('hidden'); state.seatedTable = null; };

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? { id:t.playerId, name:t.playerName||'名無し', seatIndex:Number(seatIndex) } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) { state.seatedTable = mySeat.seatIndex; seatPop.classList.add('hidden'); }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) state.seatedTable = null;

    await syncSeatUI();
    renderPlayerCircle(players);
    scheduleLastSurvivorCheck();
  });
}

function radToDeg(r){ return r * 180 / Math.PI; }

/* 遺跡描画（2x3） */
function renderRuinsArea(){
  const wrap = document.createElement('div');
  wrap.className = 'ruins-area';

  const mine6Selecting = !!(ui.effect6Selecting && state.effect6 && state.effect6.playerId === state.userId && state.effect6.phase === 'select');
  const mine7Picking   = !!(ui.effect7Picking && state.effect7 && state.effect7.playerId === state.userId && state.effect7.phase === 'pickRuins');
  const mine7Placing   = !!(ui.effect7Placing && state.effect7 && state.effect7.playerId === state.userId && state.effect7.phase === 'placeBack');

  if (mine6Selecting || mine7Picking || mine7Placing) wrap.classList.add('drop-enabled');

  const slots = getRuinsSlots();

  for (let i=0;i<6;i++){
    const slot = document.createElement('div');
    slot.className = 'ruins-slot';
    slot.dataset.i = String(i);
    if (mine7Placing && Number(ui.effect7TargetSlot) === i) slot.classList.add('hint-target');
    wrap.appendChild(slot);
  }

  for (let i=0;i<6;i++){
    const item = slots[i];
    if (!item) continue;

    const card = document.createElement('div');
    card.className = 'ruins-card';
    card.dataset.i = String(i);
    card.dataset.value = String(item?.v ?? item ?? '');
    card.textContent = '';

    const revealedValue = explorationRevealState.ruins.get(i);
    if (revealedValue != null && String(revealedValue) === String(item)){
      card.classList.add('exploration-front');
      setCardFace(card, item);
    }

    if (mine7Picking){
      card.classList.add('pickable');
      card.addEventListener('pointerdown', onRuinPointerDown);
      card.addEventListener('pointermove', onRuinPointerMove);
      card.addEventListener('pointerup', onRuinPointerUp);
      card.addEventListener('pointercancel', onRuinPointerUp);
    }

    wrap.appendChild(card);
  }

  return wrap;
}

/* ★③/④：矢印描画（点線） */
function renderEffectArrowLayer(players){
  const ef3 = state.effect3;
  const ef4 = state.effect4;
  const ef8 = state.effect8;

  let config = null;

  if (tempArrowConfig && tempArrowConfig.show){
    config = { ...tempArrowConfig };
  } else if (ef3 && ef3.phase === 'confirm' && ef3.playerId && ef3.targetPlayerId){
    config = {
      fromPid: ef3.playerId,
      toPid: ef3.targetPlayerId,
      targetCardIndex: ef3.targetCardIndex,
      showEye: true,
      bothEnds: false,
      show: state.userId !== ef3.playerId,
    };
  } else if (ef4 && ef4.phase === 'confirm' && ef4.playerId && ef4.targetPlayerId){
    config = {
      fromPid: ef4.playerId,
      toPid: ef4.targetPlayerId,
      targetCardIndex: ef4.targetCardIndex,
      showEye: true,
      bothEnds: false,
      show: state.userId !== ef4.playerId,
    };
  } else if (ef8 && ef8.phase === 'return' && ef8.playerId && ef8.targetPlayerId){
    config = {
      fromPid: ef8.playerId,
      toPid: ef8.targetPlayerId,
      targetCardIndex: null,
      showEye: false,
      bothEnds: true,
      show: true,
    };
  }

  const overlay = getEffectArrowOverlay();
  overlay.innerHTML = '';

  if (!config || !config.show){
    return;
  }

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  const w = window.innerWidth;
  const h = window.innerHeight;
  svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
  svg.setAttribute('width', String(w));
  svg.setAttribute('height', String(h));

  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  const markerId = `arrowHead-${Math.random().toString(16).slice(2)}`;
  const markerEndId = `${markerId}-end`;
  const markerStartId = `${markerId}-start`;

  const markerEnd = document.createElementNS('http://www.w3.org/2000/svg','marker');
  markerEnd.setAttribute('id', markerEndId);
  markerEnd.setAttribute('markerWidth', '10');
  markerEnd.setAttribute('markerHeight', '10');
  markerEnd.setAttribute('refX', '8');
  markerEnd.setAttribute('refY', '5');
  markerEnd.setAttribute('orient', 'auto');
  const endPath = document.createElementNS('http://www.w3.org/2000/svg','path');
  endPath.setAttribute('d', 'M0,0 L10,5 L0,10 Z');
  endPath.setAttribute('class', 'head');
  markerEnd.appendChild(endPath);
  defs.appendChild(markerEnd);

  if (config.bothEnds){
    const markerStart = document.createElementNS('http://www.w3.org/2000/svg','marker');
    markerStart.setAttribute('id', markerStartId);
    markerStart.setAttribute('markerWidth', '10');
    markerStart.setAttribute('markerHeight', '10');
    markerStart.setAttribute('refX', '2');
    markerStart.setAttribute('refY', '5');
    markerStart.setAttribute('orient', 'auto-start-reverse');
    const startPath = document.createElementNS('http://www.w3.org/2000/svg','path');
    startPath.setAttribute('d', 'M0,0 L10,5 L0,10 Z');
    startPath.setAttribute('class', 'head');
    markerStart.appendChild(startPath);
    defs.appendChild(markerStart);
  }

  svg.appendChild(defs);

  const line = document.createElementNS('http://www.w3.org/2000/svg','line');
  line.setAttribute('class', 'line');
  line.setAttribute('marker-end', `url(#${markerEndId})`);
  if (config.bothEnds){
    line.setAttribute('marker-start', `url(#${markerStartId})`);
  }
  svg.appendChild(line);

  let eye = null;
  if (config.showEye){
    eye = document.createElementNS('http://www.w3.org/2000/svg','text');
    eye.setAttribute('class', 'eye');
    eye.textContent = '👀';
    svg.appendChild(eye);
  }

  overlay.appendChild(svg);

  requestAnimationFrame(() => {
    const fromEl = getPlayerAnchorEl(config.fromPid);
    const toEl = config.showEye
      ? (getPlayerCardAnchorEl(config.toPid, config.targetCardIndex) || getPlayerAnchorEl(config.toPid))
      : getPlayerAnchorEl(config.toPid);
    if (!fromEl || !toEl) return;

    const fr = fromEl.getBoundingClientRect();
    const tr = toEl.getBoundingClientRect();

    const fx = fr.left + fr.width / 2;
    const fy = fr.top + fr.height / 2;
    const tx = tr.left + tr.width / 2;
    const ty = tr.top + tr.height / 2;

    line.setAttribute('x1', String(fx));
    line.setAttribute('y1', String(fy));
    line.setAttribute('x2', String(tx));
    line.setAttribute('y2', String(ty));

    if (eye){
      const mx = (fx + tx) / 2;
      const my = (fy + ty) / 2;
      eye.setAttribute('x', String(mx));
      eye.setAttribute('y', String(my));
    }
  });
}

function showTempArrow({ fromPid, toPid, targetCardIndex, showEye = false, bothEnds = false, durationMs = 1200 } = {}){
  if (!fromPid || !toPid) return;
  tempArrowConfig = {
    fromPid,
    toPid,
    targetCardIndex,
    showEye,
    bothEnds,
    show: true,
  };
  renderEffectArrowLayer(latestPlayers);
  setTimeout(() => {
    if (!tempArrowConfig) return;
    tempArrowConfig = null;
    renderEffectArrowLayer(latestPlayers);
  }, durationMs);
}

function renderPlayerCircle(players){
  playerCircle.innerHTML = '';
  playerCircle.appendChild(deckPile);
  playerCircle.appendChild(centerArea);

  playerCircle.appendChild(renderRuinsArea());

  if (!players.length){
    renderEffectArrowLayer([]);
    return;
  }

  const n = players.length;
  const radius = 70;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  // ★③/④：使用者のみ選択可能か
  const e3MineSelecting = !!(state.effect3 && state.effect3.playerId === state.userId && state.effect3.phase === 'select');
  const e4MineSelecting = !!(state.effect4 && state.effect4.playerId === state.userId && state.effect4.phase === 'select');
  const e8MineSelecting = !!(state.effect8 && state.effect8.playerId === state.userId && state.effect8.phase === 'select');
  const pickMode = (e3MineSelecting || e4MineSelecting || e8MineSelecting) && !state.gameOver;

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const isElim = !!state.eliminated?.[p.id];

    if (p.id === state.userId){
      const tag = document.createElement('div');
      tag.className = 'player-tag me player-anchor';
      tag.textContent = p.name + (isElim ? '（脱落）' : '');
      tag.style.left = `${x}%`;
      tag.style.top  = `${y}%`;
      tag.dataset.pid = p.id;
      if (isElim){
        tag.style.opacity = '.55';
        tag.style.filter = 'grayscale(1)';
      }
      playerCircle.appendChild(tag);
    } else {
      const fan = document.createElement('div');
      fan.className = 'player-fan player-anchor';
      fan.style.left = `${x}%`;
      fan.style.top  = `${y}%`;
      fan.dataset.pid = p.id;
      fan.title = p.name;

      if (ui.effect8Returning && ui.effect8TargetPlayerId === p.id && e8drag.active){
        fan.classList.add('effect8-drop-target');
        if (e8drag.overTarget) fan.classList.add('effect8-drop-active');
      }

      // ★③/④選択中（使用者のみ）→ 他プレイヤーの扇をクリック可
      if (pickMode && !isElim){
        fan.classList.add('pick-mode');
      }

      const handData = state.hands[p.id];
      const handCards = Array.isArray(handData?.cards) ? handData.cards : [];
      const miniHand = document.createElement('div');
      miniHand.className = 'mini-hand';

      const count = handCards.length;
      const spread = 78;
      const base = (count > 1) ? (-spread/2) : 0;
      const ef3TargetIndex = (state.effect3 && state.effect3.phase === 'confirm' && state.effect3.targetPlayerId === p.id)
        ? Number(state.effect3.targetCardIndex)
        : null;
      const ef4TargetIndex = (state.effect4 && state.effect4.phase === 'confirm' && state.effect4.targetPlayerId === p.id)
        ? Number(state.effect4.targetCardIndex)
        : null;
      const targetIndex = Number.isFinite(ef3TargetIndex) ? ef3TargetIndex : (Number.isFinite(ef4TargetIndex) ? ef4TargetIndex : null);
      const minCountForTarget = Number.isFinite(targetIndex) ? Math.min(count, Math.max(1, targetIndex + 1)) : 0;

      const visibleCount = Math.min(count, Math.max(0, 6, minCountForTarget));
      for(let i2=0;i2<visibleCount;i2++){
        const card = document.createElement('div');
        card.className = 'mini-card';

        const angleDeg = (visibleCount > 1) ? base + (spread/(visibleCount-1))*i2 : 0;
        card.style.setProperty('--rot', `${angleDeg}deg`);
        card.style.transform = `translate(-50%,0) rotate(${angleDeg}deg)`;
        card.style.zIndex = String(10 + i2);
        card.dataset.value = String(handCards[i2] ?? '');
        card.dataset.pid = p.id;
        card.dataset.idx = String(i2);

        const revealedIndexes = explorationRevealState.players.get(p.id);
        const revealedValue = revealedIndexes ? revealedIndexes.get(i2) : null;
        if (revealedValue != null && handCards[i2] != null && String(revealedValue) === String(handCards[i2])){
          card.classList.add('exploration-front');
          setCardFace(card, handCards[i2]);
        }

        card.addEventListener('pointerdown', (ev) => startZoomTap(ev, card));

        // ★③/④：使用者が選択中なら pickable
        if (pickMode && !isElim){
          card.classList.add('pickable');

          // ここでカードを選ぶ（クリックしたカード番号を「そのまま index」として扱う）
          card.addEventListener('click', async (ev) => {
            ev.stopPropagation();
            // 連打防止：一旦すべてのpickable解除
            playerCircle.querySelectorAll('.mini-card.pickable').forEach(el => {
              el.classList.remove('pickable');
              el.style.pointerEvents = 'none';
            });

            const pid = card.dataset.pid;
            const idxSel = Number(card.dataset.idx || 0);

            if (e3MineSelecting){
              await handleEffect3Pick(pid, idxSel);
            } else if (e4MineSelecting){
              await handleEffect4Pick(pid, idxSel);
            } else if (e8MineSelecting){
              await handleEffect8Pick(pid, idxSel);
            }
          }, { once:true });
        }

        // 脱落者は見た目落とす
        if (isElim){
          card.style.opacity = '.35';
          card.style.filter = 'grayscale(1)';
        }

        miniHand.appendChild(card);
      }

      const name = document.createElement('div');
      name.className = 'fan-name';
      name.textContent = p.name + (isElim ? '（脱落）' : '');

      fan.appendChild(miniHand);
      fan.appendChild(name);
      playerCircle.appendChild(fan);
    }

    const playedArr = Array.isArray(state.played?.[p.id]) ? state.played[p.id] : [];
    if (playedArr.length){
      const row = document.createElement('div');
      row.className = 'played-row';
      row.dataset.pid = p.id;

      const HAND_OUT_PUSH = 16;
      const INNER_PUSH    = 80;

      const ox = (Math.cos(angle) * HAND_OUT_PUSH) + (-Math.cos(angle) * INNER_PUSH);
      const oy = (Math.sin(angle) * HAND_OUT_PUSH) + (-Math.sin(angle) * INNER_PUSH);

      row.style.left = `${x}%`;
      row.style.top  = `${y}%`;

      const toCenterDeg = radToDeg(angle + Math.PI);
      const cardRotate = toCenterDeg + 90;

      const MAX_SHOW = 10;
      const slice = playedArr.slice(Math.max(0, playedArr.length - MAX_SHOW));

      const parallel = (p.id !== state.userId) && (slice.length === 2 || slice.length === 3 || slice.length === 4);

      if (parallel){
        row.style.transform =
          `translate(-50%,-50%) translate(${ox}px, ${oy}px) rotate(${cardRotate}deg)`;
      } else {
        row.style.transform =
          `translate(-50%,-50%) translate(${ox}px, ${oy}px)`;
      }

      slice.forEach(v => {
        const c = document.createElement('div');
        c.className = 'played-card';
        setCardFace(c, v);

        if (!parallel){
          c.style.transform = `rotate(${cardRotate}deg)`;
        } else {
          c.style.transform = `rotate(0deg)`;
        }

        c.addEventListener('pointerdown', (ev) => startZoomTap(ev, c));

        row.appendChild(c);
      });

      playerCircle.appendChild(row);
    }
  });

  // ★③/④：点線矢印レイヤー
  renderEffectArrowLayer(players);

  updateDeckPosition();
  updateTurnUI();
  updateDeckUI();
}

/* ==== 以降：配布/ホストUI等 ==== */

function buildDeckForPlayers(playerCount){
  return DECK_SETS.flatMap((set) => (deckSetState[set.id] ? set.cards : []));
}

function toDisplayValue(v){ return String(v); }

async function dealAllCardsAndInitialDraw(){
  if (!state.roomCode) return;

  resetExplorationState({ render:false });

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const players = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? { seatIndex:Number(seatIndex), id:t.playerId, name:t.playerName||'名無し' } : null))
    .filter(Boolean)
    .sort((a,b) => a.seatIndex - b.seatIndex);

  const playerCount = players.length;
  if (playerCount <= 0) return;

  const deckRaw = buildDeckForPlayers(playerCount);
  shuffleInPlace(deckRaw);

  const hands = {};
  for (let i=0;i<players.length;i++){
    const p = players[i];
    const c1 = deckRaw.shift();
    const cards = [];
    if (c1 !== undefined) cards.push(toDisplayValue(c1));
    hands[p.id] = { cards };
  }

  const firstPlayerId = players[Math.floor(Math.random() * players.length)].id;

  const initialDraw = deckRaw.shift();
  const initialDrawDisp = (initialDraw !== undefined) ? toDisplayValue(initialDraw) : null;

  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/hands`), hands),
    set(ref(db, `rooms/${state.roomCode}/played`), {}),
    set(ref(db, `rooms/${state.roomCode}/ruins`), new Array(6).fill(null)),

    set(ref(db, `rooms/${state.roomCode}/effect2`), null),
    set(ref(db, `rooms/${state.roomCode}/effect3`), null),
    set(ref(db, `rooms/${state.roomCode}/effect4`), null),
    set(ref(db, `rooms/${state.roomCode}/effect6`), null),
    set(ref(db, `rooms/${state.roomCode}/effect7`), null),
    set(ref(db, `rooms/${state.roomCode}/effect8`), null),

    set(ref(db, `rooms/${state.roomCode}/eliminated`), {}),
    set(ref(db, `rooms/${state.roomCode}/gameOver`), null),

    set(ref(db, `rooms/${state.roomCode}/deck`), deckRaw.map(toDisplayValue)),
    set(ref(db, `rooms/${state.roomCode}/turn`), { currentPlayerId:firstPlayerId, turnSeq:1, drawn:true, paused:false, updatedAt:Date.now() }),

    set(ref(db, `rooms/${state.roomCode}/ruinMoveEvent`), null),
    set(ref(db, `rooms/${state.roomCode}/ruinTakeEvent`), null),
    set(ref(db, `rooms/${state.roomCode}/returnTopEvent`), null),
    set(ref(db, `rooms/${state.roomCode}/handTransferEvent`), null),
    set(ref(db, `rooms/${state.roomCode}/explorationFaceEvent`), null),
    set(ref(db, `rooms/${state.roomCode}/explorationPickEvent`), null),

    set(ref(db, `rooms/${state.roomCode}/fiveSlideEvent`), null),
    set(ref(db, `rooms/${state.roomCode}/xRevealEvent`), null),
    set(ref(db, `rooms/${state.roomCode}/oneRevealEvent`), null),
  ]);

  if (initialDrawDisp){
    await emitDrawEvent(firstPlayerId, 1, 'initial');
    await sleep(DRAW_COMMIT_DELAY_MS);
    await addCardToHandAtomic(firstPlayerId, initialDrawDisp);
  }
}

hostSettingsBtn.addEventListener('click', () => { if (!state.isHost) return; startPop.classList.toggle('hidden'); });
btnStartPopClose.addEventListener('click', () => { startPop.classList.add('hidden'); });

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await dealAllCardsAndInitialDraw();
  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;
  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/played`)),
    remove(ref(db, `${base}/deck`)),
    remove(ref(db, `${base}/ruins`)),

    remove(ref(db, `${base}/effect2`)),
    remove(ref(db, `${base}/effect3`)),
    remove(ref(db, `${base}/effect4`)),
    remove(ref(db, `${base}/effect6`)),
    remove(ref(db, `${base}/effect7`)),
    remove(ref(db, `${base}/effect8`)),

    remove(ref(db, `${base}/eliminated`)),
    remove(ref(db, `${base}/gameOver`)),

    remove(ref(db, `${base}/turn`)),
    remove(ref(db, `${base}/drawEvent`)),
    remove(ref(db, `${base}/returnTopEvent`)),
    remove(ref(db, `${base}/reshuffleEvent`)),
    remove(ref(db, `${base}/reshuffleLock`)),
    remove(ref(db, `${base}/ruinMoveEvent`)),
    remove(ref(db, `${base}/ruinTakeEvent`)),
    remove(ref(db, `${base}/fiveSlideEvent`)),
    remove(ref(db, `${base}/xRevealEvent`)),
    remove(ref(db, `${base}/oneRevealEvent`)),
    remove(ref(db, `${base}/explorationFaceEvent`)),
    remove(ref(db, `${base}/explorationPickEvent`)),
    remove(ref(db, `${base}/handTransferEvent`)),
  ]);
  state.seatedTable = null;
  startPop.classList.add('hidden');
  resetExplorationState();
  await syncSeatUI();
});
</script>

</body>
</html>
