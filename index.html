<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>テンプレ</title>

<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  /* ✅ main のスクロールに追従する演出レイヤー */
  .fx-layer{
    position:absolute;
    left:0; top:0;
    width:100%;
    height:100%;
    pointer-events:none;
    z-index:500;
  }

  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:520;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:525;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  .player-circle{
    position:relative;
    width:260px;height:260px;
    margin:20px auto 0;
    border-radius:50%;
    box-sizing:border-box;
    border:none;
  }

  /* ✅ 点線円（deck circle / hand circle） */
  .deck-circle{
    position:absolute;
    left:50%;
    top:65%;
    transform:translate(-50%,-50%);
    width:150px;
    height:150px;
    border:2px dashed rgba(0,0,0,.45);
    border-radius:50%;
    background:none !important;
    box-shadow:none !important;
    pointer-events:none;
    z-index:4;
  }

  .player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:120px;height:90px;pointer-events:none;
    overflow:visible;
  }
  .player-tag .mini-hand::before{
    content:"";
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    width:130px;
    height:130px;
    border:2px dashed rgba(0,0,0,.45);
    border-radius:50%;
    background:none !important;
    box-shadow:none !important;
    pointer-events:none;
    z-index:0;
  }
  .player-tag .mini-card{ z-index:1; }

  :root{
    --back-fit: contain;
    --back-pos: center;
    --back-repeat: no-repeat;
    --back-bg: transparent;
  }

  .center-deck{
    position:absolute;
    left:50%; top:65%;
    transform:translate(-50%,-50%);
    width:42px; height:63px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.75);
    box-shadow:0 14px 30px rgba(0,0,0,.25);
    background-color:var(--back-bg);
    background-image:
      linear-gradient(135deg, rgba(255,255,255,.25), rgba(255,255,255,.05)),
      url('mokuura.jpg');
    background-size:
      cover,
      var(--back-fit);
    background-position:
      center,
      var(--back-pos);
    background-repeat:
      no-repeat,
      var(--back-repeat);
    z-index:5;
    user-select:none;
    -webkit-user-select:none;
    touch-action:none;
    transition:opacity .2s ease;
  }
  .center-deck.empty{ opacity:0; pointer-events:none; }
  .center-deck::before,
  .center-deck::after{
    content:'';
    position:absolute;
    inset:0;
    border-radius:10px;
    pointer-events:none;
  }
  .center-deck::before{
    transform:translate(4px,4px);
    background:rgba(0,0,0,.12);
    z-index:-1;
    filter:blur(.2px);
  }
  .center-deck::after{ border:1px solid rgba(255,255,255,.20); }
  .center-deck.shuffling{
    background:none !important;
    border:none !important;
    box-shadow:none !important;
    opacity:1 !important;
    pointer-events:none;
  }
  .center-deck.shuffling::before,
  .center-deck.shuffling::after{ opacity:0 !important; }

  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    z-index:20;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  .player-tag .mini-card{
    position:absolute;left:50%;top:0;
    width:42px; height:63px;
    border-radius:8px;border:1px solid rgba(255,255,255,.75);
    background-color:var(--back-bg);
    background-image:
      linear-gradient(135deg, rgba(255,255,255,.25), rgba(255,255,255,.05)),
      url('mokuura.jpg');
    background-size:
      cover,
      var(--back-fit);
    background-position:
      center,
      var(--back-pos);
    background-repeat:
      no-repeat,
      var(--back-repeat);
    transform-origin:bottom center;
    box-shadow:0 6px 16px rgba(0,0,0,.18);
  }

  .my-hand-wrapper{margin-top:16px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand{
    display:flex;justify-content:center;gap:8px;margin-top:22px;min-height:100px;
    position:relative;
  }
  .hand-anchor{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:1px;height:1px;opacity:0;pointer-events:none;
  }

  .my-card{
    width:60px;height:90px;border-radius:8px;border:1px solid #ddd;background:#fff;
    display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:800;
    box-shadow:0 4px 12px rgba(0,0,0,.15);
    overflow:hidden;text-align:center;padding:6px;box-sizing:border-box;line-height:1.1;
    user-select:none;-webkit-user-select:none;
    touch-action:none;
    outline:none;
  }
  .my-card:focus{ outline:none; }

  /* ✅ ドラッグ中も「カード本体」を表示する（body直下に出す） */
  .my-card.dragging{
    position:fixed !important;
    left:0; top:0;
    z-index:99999999;
    pointer-events:none;
    margin:0 !important;
    box-shadow:0 18px 40px rgba(0,0,0,.30);
    will-change:transform;
    outline:none !important;
    transform-origin:center;
    animation:none !important;
  }

  /* ✅ 演出レイヤーに置く“残留カード”（mainスクロール追従） */
  .my-card.fx-hold{
    position:absolute !important;
    left:0; top:0;
    margin:0 !important;
    pointer-events:none;
    z-index:510;
    will-change:transform, opacity;
  }

  /* ✅ ドロップ後：そのまま相手手札用の「裏カード見た目」に変える */
  .my-card.as-back{
    border:1px solid rgba(255,255,255,.75);
    background-color:var(--back-bg);
    background-image:
      linear-gradient(135deg, rgba(255,255,255,.25), rgba(255,255,255,.05)),
      url('mokuura.jpg');
    background-size:
      cover,
      var(--back-fit);
    background-position:
      center,
      var(--back-pos);
    background-repeat:
      no-repeat,
      var(--back-repeat);
    color:transparent;
    text-shadow:none;
    padding:0;
  }

  /* ✅ 元の場所に残るプレースホルダ */
  .drag-placeholder{
    width:60px;height:90px;
    border-radius:8px;
    border:none;
    background:transparent;
    box-shadow:none;
    box-sizing:border-box;
    pointer-events:none;
  }

  /* ✅ 手番の手札：大小アニメ */
  @keyframes handPulse{
    0%{ transform:translateY(0) scale(1); }
    50%{ transform:translateY(-1px) scale(1.08); }
    100%{ transform:translateY(0) scale(1); }
  }
  .my-hand.turn-active .my-card:not(.dragging){
    animation: handPulse 680ms ease-in-out infinite;
  }

  .sp3-pulse{ animation:sp3Pulse 820ms ease-in-out infinite; }
  .sp3-drop-hint{
    box-shadow:0 0 0 3px rgba(59,130,246,.22), 0 0 0 8px rgba(59,130,246,.14) !important;
    border-color:#3b82f6 !important;
  }
  @keyframes sp3Pulse{
    0%,100%{ transform:scale(1); }
    50%{ transform:scale(1.12); }
  }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:600;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:540;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:545;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:550;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:100000000;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}

  .help-grid{
    display:grid;
    grid-template-columns:repeat(4, minmax(0, 1fr));
    gap:10px;
  }
  .help-card-btn{
    appearance:none;border:1px solid #ddd;border-radius:12px;padding:0;
    background:#f8f8f8;width:100%;aspect-ratio:2/3;
    background-size:cover;background-position:center;cursor:default;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    position:relative;overflow:hidden;user-select:none;-webkit-user-select:none;
  }
  .help-card-btn.host-clickable{ cursor:pointer; }
  .help-card-btn.dim{ opacity:.28; filter:grayscale(1); }
  .help-card-btn:active{ transform:translateY(1px); }

  :root{
    --shCardW:42px;
    --shCardH:63px;
    --shOffsetX:4px;
    --shOffsetY:4px;
    --shOutX:66px;
    --shTiltBase:5deg;
    --shTiltMore:5deg;
    --shDurOut:220ms;
    --shDurIn:220ms;
    --shPause:20ms;
    --shRadius:10px;
  }

  .shuffle-overlay{
    position:absolute;
    left:0; top:0;
    width:var(--shCardW);
    height:var(--shCardH);
    pointer-events:none;
    z-index:520;
  }

  .shuffle-deck{ position:absolute; left:0; top:0; width:var(--shCardW); height:var(--shCardH); pointer-events:none; }
  .shcard{
    position:absolute; inset:0;
    border:none; outline:none;
    border-radius:var(--shRadius);
    background-color:var(--back-bg);
    background-image:
      linear-gradient(135deg, rgba(255,255,255,.20), rgba(255,255,255,.05)),
      url('mokuura.jpg');
    background-size: cover, var(--back-fit);
    background-position: center, var(--back-pos);
    background-repeat: no-repeat, var(--back-repeat);
    box-shadow:none;
    transform-origin:center;
    will-change:transform;
  }
  .shback{ transform: translate(var(--shOffsetX), var(--shOffsetY)) rotate(var(--shTiltBase)); z-index:1; }
  .shfront{ transform: translate(0,0) rotate(var(--shTiltBase)); z-index:2; }
  .shMovingOut{ transition: transform var(--shDurOut) ease-in-out; transform: translate(var(--shOutX), 0) rotate(calc(var(--shTiltBase) + var(--shTiltMore))); }
  .shMovingIn{ transition: transform var(--shDurIn) ease-in-out; transform: translate(var(--shOffsetX), var(--shOffsetY)) rotate(var(--shTiltBase)); }

  .fly-card{
    position:absolute;
    width:42px;height:63px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.75);
    background-color:var(--back-bg);
    background-image:
      linear-gradient(135deg, rgba(255,255,255,.25), rgba(255,255,255,.05)),
      url('mokuura.jpg');
    background-size: cover, var(--back-fit);
    background-position: center, var(--back-pos);
    background-repeat: no-repeat, var(--back-repeat);
    box-shadow:0 18px 40px rgba(0,0,0,.28);
    pointer-events:none;
    z-index:515;
    will-change:transform, opacity;
  }
  .fly-card.holding{ transition: opacity 140ms ease; }
  .fly-card.fading{ opacity:0; }

  .deck-park-card{
    position:absolute;
    width:42px;height:63px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.75);
    background-color:var(--back-bg);
    background-image:
      linear-gradient(135deg, rgba(255,255,255,.25), rgba(255,255,255,.05)),
      url('mokuura.jpg');
    background-size: cover, var(--back-fit);
    background-position: center, var(--back-pos);
    background-repeat: no-repeat, var(--back-repeat);
    box-shadow:0 18px 40px rgba(0,0,0,.28);
    pointer-events:none;
    z-index:505;
    will-change:transform, opacity;
  }

  .butler-layer{ position:absolute; inset:0; pointer-events:none; z-index:520; }
  .butler-card{
    position:absolute;
    width:42px;height:63px;
    border-radius:10px;
    transform-style:preserve-3d;
    perspective:900px;
    will-change:transform;
    pointer-events:none;
    filter:drop-shadow(0 18px 40px rgba(0,0,0,.30));
  }
  .butler-card .inner{ position:absolute; inset:0; border-radius:10px; transform-style:preserve-3d; transition:transform 260ms ease; }
  .butler-card .face{
    position:absolute; inset:0; border-radius:10px;
    backface-visibility:hidden;
    border:1px solid rgba(255,255,255,.75);
    background-color:var(--back-bg);
    background-size:var(--back-fit);
    background-position:var(--back-pos);
    background-repeat:var(--back-repeat);
  }
  .butler-card .back{
    background-image:
      linear-gradient(135deg, rgba(255,255,255,.25), rgba(255,255,255,.05)),
      url('mokuura.jpg');
    background-size: cover, var(--back-fit);
    background-position: center, var(--back-pos);
    background-repeat: no-repeat, var(--back-repeat);
  }
  .butler-card .front{
    transform:rotateY(180deg);
    background-image:url('殺人鬼.jpg');
    background-size:cover;background-position:center;background-repeat:no-repeat;
  }
  .butler-card.flipped .inner{ transform:rotateY(180deg); }

  /* =========================
     ✅ 「議論開始！」ポップ（左→中央で1秒停止→右へ消える）
     ========================= */
  @keyframes discussionFlow{
    0%   { transform:translate(-150%,-50%) scale(1); opacity:0; }
    18%  { transform:translate(-50%,-50%)  scale(1); opacity:1; } /* 左から中央へ */
    68%  { transform:translate(-50%,-50%)  scale(1); opacity:1; } /* 中央で停止(約1秒) */
    100% { transform:translate(150%,-50%)  scale(1); opacity:0; } /* 右へ流れて消える */
  }
  .discussion-pop{
    position:fixed;
    left:50%;
    top:50%;
    padding:18px 28px;
    background:rgba(20,20,20,.92);
    color:#fff;
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    font-weight:900;
    font-size:26px;
    letter-spacing:.02em;
    white-space:nowrap;
    pointer-events:none;
    z-index:530; /* ヘルプ(100000000)より必ず後ろ */
    will-change:transform, opacity;
    transform:translate(-150%,-50%);
    animation:discussionFlow 2100ms cubic-bezier(.22,.84,.44,1) forwards;
  }
</style>
</head>

<body>
<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">
      <div id="deckCircle" class="deck-circle" aria-hidden="true"></div>
      <div id="centerDeck" class="center-deck empty" aria-label="山札"></div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand">
        <div id="handAnchor" class="hand-anchor"></div>
      </div>
    </div>
  </div>

  <div id="fxLayer" class="fx-layer" aria-hidden="true"></div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>
<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    ✅今回の配布ルール：<br>
    ・スタート押下 → ランダム1人を手番にする<br>
    ・手番開始時 → 通常「1枚」配布（ホストがDBで確定）<br>
    ・ただし最初の手番プレイヤーだけ → 最初の手番開始時に「2枚」配布<br>
    ・手番プレイヤーが次プレイヤーへカードをドラッグしたら手番移動 → 次手番開始でまた「1枚」<br>
    ・✅ただし「最初の手番の直前の人」だけは → 次プレイヤーではなく「デッキへドロップ」し、横向きで残る<br>
    ・✅最後の人がデッキへ置いたら「議論開始！」ポップが流れる
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue, remove } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
  authDomain: "timebomb-3b0c7.firebaseapp.com",
  databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
  projectId: "timebomb-3b0c7",
  storageBucket: "timebomb-3b0c7.firebasestorage.app",
  messagingSenderId: "532935786630",
  appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
  measurementId: "G-K8NRR8K64Y"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const ROLE_NAMES = [
  "黄客人1","黄客人2","赤客人","青客人","殺人鬼",
  "共犯者","執事","富豪","弁護士","探偵","爆弾魔",
];
const DEFAULT_ENABLED = new Set(["黄客人1","黄客人2","赤客人","青客人","殺人鬼"]);

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  room: {},
  deckRemaining: [],
  activeTurn: null,
  turnDrawnTurnId: null,
  drawingTurnId: null,

  inTransit: new Map(),
  pendingOutgoing: null,
  starterPlayerId: null,

  deckParked: null,
  deckParkEl: null,

  sp3Mode: null,
};

const SP3_NAME = 'sp3';

const mainEl = document.getElementById('main');
const fxLayer = document.getElementById('fxLayer');

const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');
const handAnchor = document.getElementById('handAnchor');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const centerDeck = document.getElementById('centerDeck');
const deckCircle = document.getElementById('deckCircle');

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

/* =========================
   ★ 便利
   ========================= */
const wait = (ms) => new Promise(r => setTimeout(r, ms));
function rectCenter(r){ return { x: r.left + r.width/2, y: r.top + r.height/2 }; }
function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

function handCount(playerId){
  return Array.isArray(state.hands?.[playerId]?.cards) ? state.hands[playerId].cards.length : 0;
}

/* =========================
   ✅ 「議論開始！」ポップ
   ========================= */
function showDiscussionPop(){
  // 連打対策：同時に複数出ないように
  document.querySelectorAll('.discussion-pop').forEach(el => el.remove());

  const el = document.createElement('div');
  el.className = 'discussion-pop';
  el.textContent = '議論開始！';
  document.body.appendChild(el);

  // 2.1s後に削除（CSSと一致）
  setTimeout(()=>{ try{ el.remove(); }catch{} }, 2300);
}
let lastDiscussionEventId = null;
function subscribeDiscussionPopEvent(){
  const r = ref(db, `rooms/${state.roomCode}/discussionPopEvent`);
  onValue(r, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastDiscussionEventId) return;
    lastDiscussionEventId = ev.id;
    showDiscussionPop();
  });
}

/* =========================
   ✅ main座標系（スクロール追従）に変換
   ========================= */
function getMainRect(){ return mainEl.getBoundingClientRect(); }
function toMainXY(clientX, clientY){
  const mr = getMainRect();
  return {
    x: (clientX - mr.left) + mainEl.scrollLeft,
    y: (clientY - mr.top)  + mainEl.scrollTop,
  };
}
function rectCenterInMain(el){
  const r = el.getBoundingClientRect();
  const c = rectCenter(r);
  return toMainXY(c.x, c.y);
}

/* =========================
   ✅ 飛んでいる「実体」をDB反映まで残す
   ========================= */
function registerTransit(key, el, toId, expectedToCount, ttlMs=2200){
  const expiresAt = Date.now() + ttlMs;
  state.inTransit.set(key, { el, toId, expectedToCount, expiresAt });
  setTimeout(() => {
    const t = state.inTransit.get(key);
    if (!t) return;
    if (Date.now() >= t.expiresAt){
      try{
        t.el.classList.add('holding','fading');
        setTimeout(()=>{ try{ t.el.remove(); }catch{} }, 180);
      }catch{}
      state.inTransit.delete(key);
    }
  }, ttlMs + 30);
}

function resolveTransits(){
  for (const [key, t] of state.inTransit.entries()){
    if (t.toId === '__deck__') continue;
    const cur = handCount(t.toId);
    if (cur >= t.expectedToCount){
      try{
        t.el.classList.add('holding');
        requestAnimationFrame(() => {
          t.el.classList.add('fading');
          setTimeout(()=>{ try{ t.el.remove(); }catch{} }, 180);
        });
      }catch{}
      state.inTransit.delete(key);
    }
  }
}

/* =========================
   ✅ 全端末で「手札表示を完全にDB準拠に戻す」
   ========================= */
function clearLocalHandVisuals(){
  try{ myHandEl.replaceChildren(handAnchor); } catch {}
  document.querySelectorAll('.mini-hand .mini-card').forEach(el => el.remove());
  document.querySelectorAll('.my-card.dragging').forEach(el=>{
    try{ el.remove(); }catch{}
  });
  fxLayer.querySelectorAll('.fly-card,.deck-park-card,.shuffle-overlay,.butler-layer,.my-card.fx-hold').forEach(el=>{
    try{ el.remove(); }catch{}
  });
}

/* =========================
   ★ フライ演出（main追従：fxLayerに置く）
   ========================= */
function spawnFlyCardAt(fromEl){
  const fr = fromEl.getBoundingClientRect();
  if (!fr.width || !fr.height) return null;

  const f = rectCenter(fr);
  const p = toMainXY(f.x, f.y);

  const fly = document.createElement('div');
  fly.className = 'fly-card';

  const w = 42, h = 63;
  fly.style.left = `${p.x - w/2}px`;
  fly.style.top  = `${p.y - h/2}px`;
  fxLayer.appendChild(fly);

  return fly;
}

function animateFlyCardPersistent(fromEl, toEl, opts={}){
  const dur = opts.duration ?? 420;
  const delay = opts.delay ?? 0;
  if (!fromEl || !toEl) return null;

  const fr = fromEl.getBoundingClientRect();
  const tr = toEl.getBoundingClientRect();
  if (!fr.width || !fr.height || !tr.width || !tr.height) return null;

  const f = rectCenter(fr);
  const t = rectCenter(tr);

  const fLocal = toMainXY(f.x, f.y);
  const tLocal = toMainXY(t.x, t.y);

  const fly = spawnFlyCardAt(fromEl);
  if (!fly) return null;

  const dx = (tLocal.x - fLocal.x);
  const dy = (tLocal.y - fLocal.y);

  const rot0 = opts.rotateFrom ?? (-8);
  const rot1 = opts.rotateTo ?? (12);
  const s0 = opts.scaleFrom ?? 1.03;
  const s1 = opts.scaleTo ?? 0.98;

  const anim = fly.animate(
    [
      { transform:`translate(0px,0px) rotate(${rot0}deg) scale(${s0})`, opacity:1, offset:0 },
      { transform:`translate(${dx*0.80}px,${dy*0.80}px) rotate(${rot1}deg) scale(${(s0+s1)/2})`, opacity:1, offset:0.84 },
      { transform:`translate(${dx}px,${dy}px) rotate(${rot1}deg) scale(${s1})`, opacity:1, offset:1 },
    ],
    { duration: dur, delay, easing:'cubic-bezier(.22,.84,.22,1)', fill:'forwards' }
  );

  anim.onfinish = () => {
    fly.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot1}deg) scale(${s1})`;
    fly.classList.add('holding');
  };

  return { fly, anim };
}

function getPlayerTagEl(playerId){
  return playerCircle.querySelector(`.player-tag[data-playerid="${CSS.escape(playerId)}"]`);
}
function getMiniHandEl(playerId){
  const tag = getPlayerTagEl(playerId);
  return tag?.querySelector('.mini-hand') || null;
}

/* =========================
   ★ ルームなど
   ========================= */
function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}
async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;
  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) { mySeatIndex = Number(seatIndex); break; }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost) hostSettingsBtn.classList.add('visible');
  else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

function updateDeckVisibility(){
  const hasDeck = Array.isArray(state.deckRemaining) && state.deckRemaining.length > 0;
  centerDeck.classList.toggle('empty', !hasDeck);
}

function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    if (!helpBackdrop.classList.contains('hidden')) renderHelpList();
    syncSeatUI();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
    if (!helpBackdrop.classList.contains('hidden')) renderHelpList();
  });
}

/* ✅ starterPlayerId 購読（最後手番判定に使う） */
function subscribeStarterPlayerId(){
  const sRef = ref(db, `rooms/${state.roomCode}/starterPlayerId`);
  onValue(sRef, snap => {
    state.starterPlayerId = snap.val() || null;
  });
}

/* ✅ デッキに残るカード 購読（main追従：fxLayerに置く） */
function renderDeckParked(){
  if (state.deckParkEl){
    try{ state.deckParkEl.remove(); }catch{}
    state.deckParkEl = null;
  }
  if (!state.deckParked) return;
  const r = centerDeck.getBoundingClientRect();
  if (!r.width || !r.height) return;

  const cc = rectCenter(r);
  const p = toMainXY(cc.x, cc.y);

  const el = document.createElement('div');
  el.className = 'deck-park-card';
  el.style.left = `${p.x - 21}px`;
  el.style.top  = `${p.y - 31.5}px`;
  el.style.transform = `rotate(90deg) scale(1.0)`;
  fxLayer.appendChild(el);
  state.deckParkEl = el;
}
function subscribeDeckParked(){
  const pRef = ref(db, `rooms/${state.roomCode}/deckParked`);
  onValue(pRef, snap => {
    state.deckParked = snap.val() || null;
    renderDeckParked();
  });
}

/* =========================
   ✅ ドラッグ中は renderHands でDOMを作り直さない
   ========================= */
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    if (drag) return;
    renderHands();
    requestAnimationFrame(() => resolveTransits());
  });
}

function subscribeDeckRemaining(){
  const deckRef = ref(db, `rooms/${state.roomCode}/deckRemaining`);
  onValue(deckRef, snap => {
    state.deckRemaining = snap.val() || [];
    updateDeckVisibility();
  });
}

/* =========================
   ✅ hands reset event
   ========================= */
let lastHandsResetEventId = null;
function subscribeHandsResetEvent(){
  const rRef = ref(db, `rooms/${state.roomCode}/handsResetEvent`);
  onValue(rRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastHandsResetEventId) return;
    lastHandsResetEventId = ev.id;

    state.pendingOutgoing = null;
    state.sp3Mode = null;
    clearSp3Hints();

    for (const [,t] of state.inTransit.entries()){
      try{ t.el.remove(); }catch{}
    }
    state.inTransit.clear();

    clearLocalHandVisuals();
    renderHands();
    requestAnimationFrame(() => resolveTransits());
    renderTurnUI();
  });
}

/* =========================
   ✅ 手番ドロー済み(turnId)
   ========================= */
function subscribeTurnDrawn(){
  const rRef = ref(db, `rooms/${state.roomCode}/turnDrawnTurnId`);
  onValue(rRef, snap => {
    state.turnDrawnTurnId = snap.val() || null;
  });
}

/* =========================
   ★ 手番
   ========================= */
let lastTurnId = null;
function isMyTurn(){
  return !!(state.activeTurn && state.activeTurn.playerId === state.userId);
}
function renderTurnUI(){
  myHandEl.classList.toggle('turn-active', isMyTurn());
}

/* =========================
   ✅ 配布
   ========================= */
const DRAW_ANIM_MS = 420;
const DRAW_POST_PAD = 60;

async function hostAutoDrawOnceForTurn(turn){
  if (!state.roomCode) return;
  if (!state.isHost) return;
  if (!turn || !turn.id || !turn.playerId) return;

  if (state.drawingTurnId === turn.id) return;
  state.drawingTurnId = turn.id;

  try{
    const drawnSnap = await get(ref(db, `rooms/${state.roomCode}/turnDrawnTurnId`));
    const drawnTurnId = drawnSnap.val();
    if (drawnTurnId === turn.id) return;

    const deckSnap = await get(ref(db, `rooms/${state.roomCode}/deckRemaining`));
    const deck = deckSnap.val() || [];
    if (!Array.isArray(deck) || deck.length === 0) return;

    const starterSnap = await get(ref(db, `rooms/${state.roomCode}/starterPlayerId`));
    const starterPlayerId = starterSnap.val() || null;

    const extraGivenSnap = await get(ref(db, `rooms/${state.roomCode}/starterExtraGiven`));
    const starterExtraGiven = !!extraGivenSnap.val();

    let count = 1;
    const isStarterThisTurn = (starterPlayerId && turn.playerId === starterPlayerId);
    if (isStarterThisTurn && !starterExtraGiven) count = 2;

    if (deck.length < count) return;

    const cardsToGive = deck.slice(0, count);
    const toId = turn.playerId;

    const drawId = crypto.randomUUID();
    await set(ref(db, `rooms/${state.roomCode}/drawEvent`), {
      id: drawId,
      to: toId,
      count,
      by: state.userId,
      at: Date.now()
    });

    await wait(DRAW_ANIM_MS + DRAW_POST_PAD + (count-1)*90);

    const toSnap = await get(ref(db, `rooms/${state.roomCode}/hands/${toId}/cards`));
    const toCards = toSnap.val() || [];
    const nextCards = Array.isArray(toCards) ? toCards.concat(cardsToGive) : cardsToGive.slice();

    const updates = [
      set(ref(db, `rooms/${state.roomCode}/deckRemaining`), deck.slice(count)),
      set(ref(db, `rooms/${state.roomCode}/hands/${toId}/cards`), nextCards),
      set(ref(db, `rooms/${state.roomCode}/turnDrawnTurnId`), turn.id),
    ];
    if (count === 2) updates.push(set(ref(db, `rooms/${state.roomCode}/starterExtraGiven`), true));

    await Promise.all(updates);
  } finally {
    state.drawingTurnId = null;
  }
}

function subscribeTurn(){
  const tRef = ref(db, `rooms/${state.roomCode}/activeTurn`);
  onValue(tRef, async snap => {
    const t = snap.val() || null;
    state.activeTurn = t;
    renderTurnUI();

    if (!t || !t.id || !t.playerId) return;
    if (t.id === lastTurnId) return;
    lastTurnId = t.id;

    await hostAutoDrawOnceForTurn(t);
  });
}

/* =========================
   ★ シャッフル購読
   ========================= */
let lastShuffleEventId = null;
function subscribeShuffleEvent(){
  const shRef = ref(db, `rooms/${state.roomCode}/shuffleEvent`);
  onValue(shRef, async snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastShuffleEventId) return;
    lastShuffleEventId = ev.id;

    centerDeck.classList.remove('empty');
    await playShuffle(ev.times ?? 3);
    updateDeckVisibility();
  });
}

/* =========================
   ★ 執事演出（main追従：fxLayerに置く）
   ========================= */
let lastButlerEventId = null;
const BUTLER_STEP_MS = 1000;
const BUTLER_TOTAL_MS = 3000;
const BUTLER_POST_GAP_MS = 1000;

function makeButlerCardAtClientXY(clientX, clientY){
  const p = toMainXY(clientX, clientY);
  const card = document.createElement('div');
  card.className = 'butler-card';
  card.style.left = `${p.x - 21}px`;
  card.style.top  = `${p.y - 31.5}px`;

  const inner = document.createElement('div');
  inner.className = 'inner';

  const back = document.createElement('div');
  back.className = 'face back';

  const front = document.createElement('div');
  front.className = 'face front';

  inner.appendChild(back);
  inner.appendChild(front);
  card.appendChild(inner);
  return card;
}

async function playButlerCinematic(){
  if (!centerDeck) return;
  if (centerDeck.classList.contains('empty')) return;

  const fr = centerDeck.getBoundingClientRect();
  if (!fr.width || !fr.height) return;

  const c = rectCenter(fr);

  const oldKeep = document.getElementById('butlerKeepLayer');
  if (oldKeep) oldKeep.remove();

  const layer = document.createElement('div');
  layer.className = 'butler-layer';
  layer.id = 'butlerKeepLayer';
  fxLayer.appendChild(layer);

  const cardX = makeButlerCardAtClientXY(c.x, c.y);
  const cardY = makeButlerCardAtClientXY(c.x, c.y);
  const cardZ = makeButlerCardAtClientXY(c.x, c.y);

  cardY.style.opacity = '0';
  cardZ.style.opacity = '0';

  layer.appendChild(cardX);
  layer.appendChild(cardY);
  layer.appendChild(cardZ);

  const LEFT_X = -78;
  const CARD_W = 42;
  const GAP = 6;
  const RIGHT_BASE = 72;
  const RIGHT_Y = RIGHT_BASE;
  const RIGHT_Z = RIGHT_BASE + CARD_W + GAP;

  cardX.animate(
    [
      { transform:`translate(0px,0px) rotate(-6deg) scale(1.02)` },
      { transform:`translate(${LEFT_X}px,0px) rotate(-10deg) scale(1.02)` }
    ],
    { duration: 520, easing: 'cubic-bezier(.22,.84,.22,1)', fill:'forwards' }
  );
  setTimeout(() => cardX.classList.add('flipped'), 240);

  await wait(BUTLER_STEP_MS);

  cardY.style.opacity = '1';
  cardZ.style.opacity = '1';

  cardY.animate(
    [
      { transform:`translate(0px,0px) rotate(0deg) scale(1.02)` },
      { transform:`translate(${RIGHT_Y}px,0px) rotate(0deg) scale(1.02)` }
    ],
    { duration: 520, easing: 'cubic-bezier(.22,.84,.22,1)', fill:'forwards' }
  );
  cardZ.animate(
    [
      { transform:`translate(0px,0px) rotate(0deg) scale(1.02)` },
      { transform:`translate(${RIGHT_Z}px,0px) rotate(0deg) scale(1.02)` }
    ],
    { duration: 540, easing: 'cubic-bezier(.22,.84,.22,1)', fill:'forwards' }
  );

  await wait(BUTLER_STEP_MS);

  cardX.classList.remove('flipped');
  cardX.animate(
    [
      { transform:`translate(${LEFT_X}px,0px) rotate(-10deg) scale(1.02)` },
      { transform:`translate(0px,0px) rotate(-2deg) scale(1.02)` }
    ],
    { duration: 520, easing: 'cubic-bezier(.22,.84,.22,1)', fill:'forwards' }
  );

  await wait(560);
  cardX.remove();
}

function subscribeButlerEvent(){
  const bRef = ref(db, `rooms/${state.roomCode}/butlerEvent`);
  onValue(bRef, async snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastButlerEventId) return;
    lastButlerEventId = ev.id;

    await playButlerCinematic();
  });
}

/* =========================
   ★ 配布イベント購読（演出だけ）
   ========================= */
let lastDrawEventId = null;
function subscribeDrawEvent(){
  const dRef = ref(db, `rooms/${state.roomCode}/drawEvent`);
  onValue(dRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastDrawEventId) return;
    lastDrawEventId = ev.id;

    if (!centerDeck || centerDeck.classList.contains('empty')) return;

    const to = ev.to;
    const count = ev.count ?? 1;
    if (!to || count <= 0) return;

    const toEl = (to === state.userId) ? myHandEl : (getMiniHandEl(to) || getPlayerTagEl(to) || myHandEl);

    const base = handCount(to);
    for(let i=0;i<count;i++){
      const delay = i * 70;
      const expectedToCount = base + (i+1);
      requestAnimationFrame(() => {
        const obj = animateFlyCardPersistent(centerDeck, toEl, {
          delay,
          duration: DRAW_ANIM_MS,
          rotateFrom:-10, rotateTo:14,
          scaleFrom:1.05, scaleTo:1.02
        });
        if (!obj) return;

        registerTransit(`draw:${ev.id}:${to}:${i}`, obj.fly, to, expectedToCount, 2400);
      });
    }
  });
}

/* =========================
   ✅ 移動イベント（演出）
   ========================= */
const MOVE_ANIM_MS = 420;
const MOVE_POST_PAD = 220;

let lastMoveEventId = null;

function subscribeMoveEvent(){
  const mRef = ref(db, `rooms/${state.roomCode}/moveEvent`);
  onValue(mRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastMoveEventId) return;
    lastMoveEventId = ev.id;

    const fromId = ev.from;
    const toId   = ev.to;
    if (!fromId || !toId) return;

    if (ev.by === state.userId) return;

    const fromEl = (fromId === state.userId) ? myHandEl : (getMiniHandEl(fromId) || getPlayerTagEl(fromId) || centerDeck);
    const toEl   = (toId === state.userId) ? myHandEl : (getMiniHandEl(toId) || getPlayerTagEl(toId) || myHandEl);

    const expectedToCount = handCount(toId) + 1;

    requestAnimationFrame(() => {
      const obj = animateFlyCardPersistent(fromEl, toEl, { duration: MOVE_ANIM_MS });
      if (!obj) return;
      registerTransit(`move:${ev.id}:${toId}`, obj.fly, toId, expectedToCount, 2600);
    });
  });
}

/* ✅ 最後手番プレイヤーの「デッキへドロップ」演出イベント */
let lastDeckDropEventId = null;
function subscribeDeckDropEvent(){
  const dRef = ref(db, `rooms/${state.roomCode}/deckDropEvent`);
  onValue(dRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id) return;
    if (ev.id === lastDeckDropEventId) return;
    lastDeckDropEventId = ev.id;

    if (ev.by === state.userId) return;

    const fromId = ev.from;
    if (!fromId) return;

    const fromEl = (fromId === state.userId) ? myHandEl : (getMiniHandEl(fromId) || getPlayerTagEl(fromId) || myHandEl);
    const toEl = centerDeck;

    requestAnimationFrame(() => {
      const obj = animateFlyCardPersistent(fromEl, toEl, { duration: MOVE_ANIM_MS, rotateFrom:-10, rotateTo:22, scaleFrom:1.05, scaleTo:1.02 });
      if (!obj) return;
      registerTransit(`deckdrop:${ev.id}`, obj.fly, '__deck__', 0, 900);
    });
  });
}

/* =========================
   ★ 自分手札レンダリング（DB + ローカル差分）
   ========================= */
function buildKeys(cards){
  const occ = new Map();
  return cards.map(v => {
    const n = (occ.get(v) ?? 0) + 1;
    occ.set(v, n);
    return { v, key: `${v}__${n}` };
  });
}

function applyOutgoingDiff(rawCards){
  const p = state.pendingOutgoing;
  if (!p) return rawCards;
  if (Date.now() > p.until) { state.pendingOutgoing = null; return rawCards; }

  const cards = rawCards.slice();
  const v = p.value;

  if (Number.isFinite(p.fromIndex) && p.fromIndex >= 0 && p.fromIndex < cards.length && cards[p.fromIndex] === v){
    cards.splice(p.fromIndex, 1);
    return cards;
  }
  const idx = cards.indexOf(v);
  if (idx !== -1) cards.splice(idx, 1);
  return cards;
}

function renderMyHand(){
  const myId = state.userId;
  let cards = Array.isArray(state.hands?.[myId]?.cards) ? state.hands[myId].cards : [];
  cards = applyOutgoingDiff(cards);

  const nodes = Array.from(myHandEl.children).filter(el => el !== handAnchor);
  const byKey = new Map();
  nodes.forEach(el => {
    const k = el.dataset.key;
    if (k) byKey.set(k, el);
  });

  const desired = buildKeys(cards);
  const used = new Set();

  const frag = document.createDocumentFragment();
  frag.appendChild(handAnchor);

  desired.forEach(({v,key}) => {
    let el = byKey.get(key);
    if (!el){
      el = document.createElement('div');
      el.className = 'my-card';
    }
    el.dataset.key = key;
    el.textContent = v;
    el.style.visibility = 'visible';
    el.classList.remove('dragging','as-back','fx-hold');
    el.style.transform = '';
    el.style.position = '';
    el.style.left = '';
    el.style.top = '';
    used.add(el);
    frag.appendChild(el);
  });

  nodes.forEach(el => { if (!used.has(el)) el.remove(); });
  myHandEl.replaceChildren(frag);
}

/* =========================
   ★ プレイヤーサークル
   ========================= */
function ensureTag(player){
  let tag = getPlayerTagEl(player.id);
  if (!tag){
    tag = document.createElement('div');
    tag.className = 'player-tag' + (player.id === state.userId ? ' me' : '');
    tag.dataset.playerid = player.id;

    if (player.id !== state.userId){
      const miniHand = document.createElement('div');
      miniHand.className = 'mini-hand';
      tag.appendChild(miniHand);
    }

    tag.onclick = () => {
      if (player.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = player.seatIndex;
      pendingSeatPlayerIdToSteal = player.id;
      kickMessage.textContent = `「${player.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    playerCircle.appendChild(tag);
  }
  return tag;
}

function layoutMiniHand(tag, count){
  const miniHand = tag.querySelector('.mini-hand');
  if (!miniHand) return;

  const existing = Array.from(miniHand.querySelectorAll('.mini-card'));
  while (existing.length < count){
    const c = document.createElement('div');
    c.className = 'mini-card';
    miniHand.appendChild(c);
    existing.push(c);
  }
  while (existing.length > count){
    existing.pop().remove();
  }

  const spread = 70;
  const base = (count > 1) ? (-spread/2) : 0;
  existing.forEach((cardEl, idx2) => {
    const angleDeg = (count > 1) ? base + (spread/(count-1))*idx2 : 0;
    cardEl.style.transform = `translate(-50%,0) rotate(${angleDeg}deg)`;
    cardEl.style.zIndex = String(10 + idx2);
    cardEl.dataset.cardIndex = String(idx2);
  });
}

function renderPlayerCircle(players){
  const existingDeck = document.getElementById('centerDeck');
  if (!existingDeck) return;

  if (existingDeck.parentNode === playerCircle) playerCircle.removeChild(existingDeck);

  const want = new Set(players.map(p => p.id));
  Array.from(playerCircle.querySelectorAll('.player-tag')).forEach(tag => {
    const pid = tag.dataset.playerid;
    if (!want.has(pid)) tag.remove();
  });

  playerCircle.appendChild(existingDeck);

  if (!players.length) return;

  const n = players.length;
  const radius = 55;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const tag = ensureTag(p);
    tag.classList.toggle('me', p.id === state.userId);

    let nameSpan = tag.querySelector('span.name');
    if (!nameSpan){
      nameSpan = document.createElement('span');
      nameSpan.className = 'name';
      tag.prepend(nameSpan);
    }
    nameSpan.textContent = p.name;

    tag.style.left = `${x}%`;
    tag.style.top  = `${y}%`;

    if (p.id !== state.userId){
      const real = handCount(p.id);
      layoutMiniHand(tag, Math.max(0, real));
    }
  });

  renderTurnUI();
  renderDeckParked();
}

function renderHands(){
  renderMyHand();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);

  if (state.sp3Mode?.phase === 'pickDiscard') startSp3Phase1();
  else if (state.sp3Mode?.phase === 'sendDeck') startSp3Phase2();
}

/* =========================
   ★ URL room
   ========================= */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  if (state.isHost && (!roomData || !roomData.rolesEnabled)) {
    await update(roomRef, { rolesEnabled: roomData?.rolesEnabled || {} });
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribeStarterPlayerId();
  subscribePlayers();
  subscribeHands();
  subscribeHandsResetEvent();
  subscribeDeckRemaining();
  subscribeShuffleEvent();
  subscribeButlerEvent();
  subscribeDeckParked();

  subscribeTurnDrawn();
  subscribeTurn();

  subscribeDrawEvent();
  subscribeMoveEvent();
  subscribeDeckDropEvent();

  /* ✅ 追加：議論開始ポップ購読 */
  subscribeDiscussionPopEvent();

  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

/* =========================
   ★ help
   ========================= */
function isRoleEnabled(name){
  if (DEFAULT_ENABLED.has(name)) return true;
  const m = state.room.rolesEnabled || {};
  return !!m[name];
}
function renderHelpList(){
  helpBody.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'help-grid';

  ROLE_NAMES.forEach((name) => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'help-card-btn';
    btn.style.backgroundImage = `url('${name}.jpg')`;

    const enabled = isRoleEnabled(name);
    if (!enabled) btn.classList.add('dim');

    const hostCanClick = state.isHost && !DEFAULT_ENABLED.has(name);
    if (hostCanClick) btn.classList.add('host-clickable');

    btn.addEventListener('click', async () => {
      if (!hostCanClick) return;
      if (!state.roomCode) return;

      const path = `rooms/${state.roomCode}/rolesEnabled/${name}`;
      const currently = isRoleEnabled(name);
      if (currently) await remove(ref(db, path));
      else await set(ref(db, path), true);
    });

    grid.appendChild(btn);
  });

  helpBody.appendChild(grid);
}
function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

/* =========================
   ★ seat
   ========================= */
async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

/* =========================
   ★ players subscribe
   ========================= */
function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    if (!drag) renderPlayerCircle(players);
    renderTurnUI();

    requestAnimationFrame(() => resolveTransits());
  });
}

/* =========================
   ★ kick dialog
   ========================= */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   ★ シャッフル（fxLayerに置く）
   ========================= */
function cssMs(name){
  const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  return v.endsWith('ms') ? parseFloat(v) : (v.endsWith('s') ? parseFloat(v)*1000 : parseFloat(v));
}
const SH_DUR_OUT = cssMs('--shDurOut');
const SH_DUR_IN  = cssMs('--shDurIn');
const SH_PAUSE   = cssMs('--shPause');

function shuffleTotalMs(times){
  return times * (SH_DUR_OUT + SH_DUR_IN + SH_PAUSE);
}

function makeShuffleOverlayAtCenterDeck(){
  centerDeck.classList.add('shuffling');
  centerDeck.classList.remove('empty');

  const p = rectCenterInMain(centerDeck);

  fxLayer.querySelectorAll('.shuffle-overlay').forEach(el => el.remove());

  const overlay = document.createElement('div');
  overlay.className = 'shuffle-overlay';
  overlay.style.left = `${p.x - (42/2)}px`;
  overlay.style.top  = `${p.y - (63/2)}px`;

  const deck = document.createElement('div');
  deck.className = 'shuffle-deck';

  const back = document.createElement('div');
  back.className = 'shcard shback';

  const front = document.createElement('div');
  front.className = 'shcard shfront';

  deck.appendChild(back);
  deck.appendChild(front);
  overlay.appendChild(deck);
  fxLayer.appendChild(overlay);

  return { overlay, deck, front, back };
}

function cleanupShuffle(obj){
  if (obj?.overlay && obj.overlay.parentNode) obj.overlay.remove();
  centerDeck.classList.remove('shuffling');
  updateDeckVisibility();
  renderDeckParked();
}

function swapLayers(obj){
  obj.front.classList.remove('shfront');
  obj.front.classList.add('shback');

  obj.back.classList.remove('shback');
  obj.back.classList.add('shfront');

  const tmp = obj.front;
  obj.front = obj.back;
  obj.back = tmp;
}

async function playShuffle(times=3){
  const obj = makeShuffleOverlayAtCenterDeck();
  obj.front.classList.remove('shMovingOut','shMovingIn');
  obj.back.classList.remove('shMovingOut','shMovingIn');

  try{
    for(let i=0;i<times;i++){
      obj.front.classList.remove('shMovingIn');
      void obj.front.offsetWidth;
      obj.front.classList.add('shMovingOut');
      await wait(SH_DUR_OUT);

      obj.front.classList.remove('shMovingOut');
      swapLayers(obj);

      obj.back.classList.remove('shMovingOut');
      void obj.back.offsetWidth;
      obj.back.classList.add('shMovingIn');
      await wait(SH_DUR_IN);

      obj.back.classList.remove('shMovingIn');
      await wait(SH_PAUSE);

      if (centerDeck && obj.overlay?.isConnected){
        const pp = rectCenterInMain(centerDeck);
        obj.overlay.style.left = `${pp.x - (42/2)}px`;
        obj.overlay.style.top  = `${pp.y - (63/2)}px`;
      }
    }
  } finally {
    cleanupShuffle(obj);
  }
}

/* =========================
   ★ デッキ生成/開始処理（元のまま）
   ========================= */
function makeSelectedDeck(){ return ROLE_NAMES.filter(n => isRoleEnabled(n)); }
function shuffleArray(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
async function resetHandsEverywhere(){
  if (!state.roomCode) return;
  const id = crypto.randomUUID();
  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/hands`), {}),
    set(ref(db, `rooms/${state.roomCode}/handsResetEvent`), { id, by: state.userId, at: Date.now() })
  ]);
}
async function reviveDeckUnshuffled(){
  if (!state.roomCode) return;
  const deck = makeSelectedDeck();
  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/deckGenerated`), deck),
    set(ref(db, `rooms/${state.roomCode}/deckRemaining`), deck),
  ]);
}
async function shuffleDeckInDB(){
  if (!state.roomCode) return;
  const snap = await get(ref(db, `rooms/${state.roomCode}/deckRemaining`));
  const deck = snap.val() || [];
  const shuffled = shuffleArray(Array.isArray(deck) ? deck : []);
  await set(ref(db, `rooms/${state.roomCode}/deckRemaining`), shuffled);
}
async function pickRandomStarterAndSetTurn(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const players = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? { seatIndex:Number(seatIndex), id:t.playerId } : null))
    .filter(Boolean);

  if (!players.length) return;

  const picked = players[Math.floor(Math.random()*players.length)];

  const hands = {};
  players.forEach(p => { hands[p.id] = { cards: [] }; });

  const turnId = crypto.randomUUID();
  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/hands`), hands),
    set(ref(db, `rooms/${state.roomCode}/starterPlayerId`), picked.id),
    remove(ref(db, `rooms/${state.roomCode}/starterExtraGiven`)),
    set(ref(db, `rooms/${state.roomCode}/activeTurn`), { id: turnId, playerId: picked.id, at: Date.now() }),
    remove(ref(db, `rooms/${state.roomCode}/turnDrawnTurnId`)),
    remove(ref(db, `rooms/${state.roomCode}/deckParked`)),
  ]);
}

/* =========================
   ★ 次手番プレイヤー
   ========================= */
function getNextPlayerId(currentId){
  if (!latestPlayers.length) return null;
  const idx = latestPlayers.findIndex(p => p.id === currentId);
  if (idx === -1) return latestPlayers[0].id;
  const next = latestPlayers[(idx + 1) % latestPlayers.length];
  return next?.id || null;
}

/* ✅ 「最初の手番の直前のプレイヤー」ID */
function getPrevPlayerId(targetId){
  if (!latestPlayers.length) return null;
  const idx = latestPlayers.findIndex(p => p.id === targetId);
  if (idx === -1) return null;
  const prev = latestPlayers[(idx - 1 + latestPlayers.length) % latestPlayers.length];
  return prev?.id || null;
}
function isLastTurnPlayer(meId){
  if (!state.starterPlayerId) return false;
  const lastId = getPrevPlayerId(state.starterPlayerId);
  return !!(lastId && meId === lastId);
}

/* =========================
   ✅ 自分の手札 → 次手番 / デッキへドラッグで移動
   ========================= */
let drag = null;

function canDragNow(){
  if (!state.activeTurn?.id) return false;
  if (!isMyTurn()) return false;
  if (state.sp3Mode) return true;
  if (state.turnDrawnTurnId !== state.activeTurn.id) return false;
  return true;
}

function clearSp3Hints(){
  document.querySelectorAll('.sp3-pulse').forEach(el => el.classList.remove('sp3-pulse'));
  myHandEl.classList.remove('sp3-drop-hint');
  deckCircle.classList.remove('sp3-drop-hint');
}

function normalizeSp3(v){ return String(v || '').trim().toLowerCase(); }

function collectSp3Candidates(){
  const list = [];
  for (const p of latestPlayers){
    const cards = Array.isArray(state.hands?.[p.id]?.cards) ? state.hands[p.id].cards : [];
    cards.forEach((card, i) => {
      if (normalizeSp3(card) === SP3_NAME) return;
      list.push({ playerId:p.id, value:card, index:i });
    });
  }
  return list;
}

function startSp3Phase1(){
  clearSp3Hints();
  const candidates = collectSp3Candidates();
  if (!candidates.length){
    state.sp3Mode = null;
    advanceTurnFromPlayer(state.userId);
    return;
  }

  state.sp3Mode = { phase:'pickDiscard' };

  document.querySelectorAll('.mini-hand .mini-card').forEach(el => {
    const tag = el.closest('.player-tag');
    const playerId = tag?.dataset.playerid;
    if (!playerId) return;
    const idx = Number(el.dataset.cardIndex ?? -1);
    const cards = Array.isArray(state.hands?.[playerId]?.cards) ? state.hands[playerId].cards : [];
    const card = cards[idx];
    if (normalizeSp3(card) === SP3_NAME) return;
    el.classList.add('sp3-pulse');
  });

  Array.from(myHandEl.querySelectorAll('.my-card')).forEach((el, idx) => {
    const card = state.hands?.[state.userId]?.cards?.[idx];
    if (normalizeSp3(card) === SP3_NAME) return;
    el.classList.add('sp3-pulse');
  });
  myHandEl.classList.add('sp3-drop-hint');
}

function startSp3Phase2(){
  clearSp3Hints();
  state.sp3Mode = { phase:'sendDeck' };
  Array.from(myHandEl.querySelectorAll('.my-card')).forEach(el => el.classList.add('sp3-pulse'));
  deckCircle.classList.add('sp3-drop-hint');
}

/* ✅ 次プレイヤーのドロップ判定 */
function getDropTargetForNextPlayer(clientX, clientY){
  const nextId = getNextPlayerId(state.userId);
  if (!nextId) return null;
  const mh = getMiniHandEl(nextId);
  if (!mh) return null;

  const r = mh.getBoundingClientRect();
  const c = rectCenter(r);
  const radius = 65;
  const dx = clientX - c.x;
  const dy = clientY - c.y;
  const inside = (dx*dx + dy*dy) <= (radius*radius);
  if (!inside) return null;

  return { type:'player', playerId: nextId, el: mh, centerClient: c };
}

/* ✅ デッキエリア（点線円）へのドロップ判定 */
function getDropTargetForDeck(clientX, clientY){
  if (!deckCircle) return null;
  const r = deckCircle.getBoundingClientRect();
  const c = rectCenter(r);
  const radius = 82;
  const dx = clientX - c.x;
  const dy = clientY - c.y;
  const inside = (dx*dx + dy*dy) <= (radius*radius);
  if (!inside) return null;

  const cr = centerDeck.getBoundingClientRect();
  const cc = rectCenter(cr);
  return { type:'deck', centerClient: cc, el: centerDeck };
}

/* ✅ 共通：ドラッグ要素の位置（fixed中） */
function setDraggingPos(el, x, y){
  el.style.transform = `translate(${x}px, ${y}px)`;
}

/* ✅ 掴んだ瞬間に右へズレる対策 */
function parseMatrix(transformStr){
  if (!transformStr || transformStr === 'none') return null;
  const m = transformStr.match(/^matrix\((.+)\)$/);
  if (!m) return null;
  const parts = m[1].split(',').map(s => parseFloat(s.trim()));
  if (parts.length !== 6 || parts.some(n => Number.isNaN(n))) return null;
  const [a,b,c,d,tx,ty] = parts;
  return { a,b,c,d,tx,ty };
}
function computeStableGrabOffsets(cardEl, clientX, clientY){
  const r = cardEl.getBoundingClientRect();
  const cs = getComputedStyle(cardEl);
  const mat = parseMatrix(cs.transform);

  const baseW = 60;
  const baseH = 90;

  let scaleX = 1, scaleY = 1, tx = 0, ty = 0;
  if (mat){
    scaleX = mat.a || 1;
    scaleY = mat.d || 1;
    tx = mat.tx || 0;
    ty = mat.ty || 0;
  } else {
    scaleX = (r.width && baseW) ? (r.width / baseW) : 1;
    scaleY = (r.height && baseH) ? (r.height / baseH) : 1;
  }

  const baseLeft = r.left - tx + (baseW * (scaleX - 1) / 2);
  const baseTop  = r.top  - ty + (baseH * (scaleY - 1) / 2);

  const offsetX = clientX - baseLeft;
  const offsetY = clientY - baseTop;

  return { offsetX, offsetY, baseW, baseH };
}

/* ✅ ドロップ先へ「縮小しながら」飛ばす */
function animateDraggedCardToTarget(dragEl, fromLeft, fromTop, toCenterClient, opts={}){
  const dur = opts.duration ?? MOVE_ANIM_MS;
  const endScale = opts.endScale ?? 0.70;
  const rot0 = opts.rotateFrom ?? -6;
  const rot1 = opts.rotateTo ?? 10;

  const r = dragEl.getBoundingClientRect();
  const w = r.width || 60;
  const h = r.height || 90;

  const toLeft = toCenterClient.x - w/2;
  const toTop  = toCenterClient.y - h/2;

  const anim = dragEl.animate(
    [
      { transform:`translate(${fromLeft}px, ${fromTop}px) rotate(${rot0}deg) scale(1)` },
      { transform:`translate(${toLeft}px, ${toTop}px) rotate(${rot1}deg) scale(${endScale})` }
    ],
    { duration: dur, easing:'cubic-bezier(.22,.84,.22,1)', fill:'forwards' }
  );

  return { anim, toLeft, toTop, endScale, rot1 };
}

/* ✅ DB更新：プレイヤー間移動 */
async function moveCardToPlayer(fromId, toId, cardValue, fromIndex, opts={}){
  if (!state.roomCode) return;
  const advanceTurn = opts.advanceTurn !== false;

  const moveId = crypto.randomUUID();

  await set(ref(db, `rooms/${state.roomCode}/moveEvent`), {
    id: moveId,
    from: fromId,
    to: toId,
    card: cardValue,
    fromIndex,
    by: state.userId,
    at: Date.now()
  });

  await wait(MOVE_ANIM_MS + MOVE_POST_PAD);

  const handsSnap = await get(ref(db, `rooms/${state.roomCode}/hands`));
  const hands = handsSnap.val() || {};
  const fromCards = Array.isArray(hands?.[fromId]?.cards) ? hands[fromId].cards.slice() : [];
  const toCards   = Array.isArray(hands?.[toId]?.cards) ? hands[toId].cards.slice() : [];

  let removed = null;
  if (typeof fromIndex === 'number' && fromIndex >= 0 && fromIndex < fromCards.length && fromCards[fromIndex] === cardValue){
    removed = fromCards.splice(fromIndex, 1)[0];
  } else {
    const idx = fromCards.indexOf(cardValue);
    if (idx !== -1) removed = fromCards.splice(idx, 1)[0];
  }
  if (removed == null) return { moveId, updated:false };

  toCards.push(removed);

  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/hands/${fromId}/cards`), fromCards),
    set(ref(db, `rooms/${state.roomCode}/hands/${toId}/cards`), toCards),
  ]);

  if (advanceTurn) await advanceTurnFromPlayer(fromId);
  return { moveId, updated:true, expectedToCount: toCards.length };
}

async function advanceTurnFromPlayer(fromId){
  const nextId = getNextPlayerId(fromId);
  if (!nextId) return;
  const turnId = crypto.randomUUID();
  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/activeTurn`), { id: turnId, playerId: nextId, at: Date.now() }),
    remove(ref(db, `rooms/${state.roomCode}/turnDrawnTurnId`))
  ]);
}

/* ✅ DB更新：デッキへ（横向きで残す） */
async function moveCardToDeck(fromId, cardValue, fromIndex, opts={}){
  if (!state.roomCode) return;
  const advanceTurn = opts.advanceTurn !== false;
  const triggerDiscussion = opts.triggerDiscussion !== false;

  const dropId = crypto.randomUUID();
  await set(ref(db, `rooms/${state.roomCode}/deckDropEvent`), {
    id: dropId,
    from: fromId,
    card: cardValue,
    fromIndex,
    by: state.userId,
    at: Date.now()
  });

  await wait(MOVE_ANIM_MS + MOVE_POST_PAD);

  const handsSnap = await get(ref(db, `rooms/${state.roomCode}/hands`));
  const hands = handsSnap.val() || {};
  const fromCards = Array.isArray(hands?.[fromId]?.cards) ? hands[fromId].cards.slice() : [];

  let removed = null;
  if (typeof fromIndex === 'number' && fromIndex >= 0 && fromIndex < fromCards.length && fromCards[fromIndex] === cardValue){
    removed = fromCards.splice(fromIndex, 1)[0];
  } else {
    const idx = fromCards.indexOf(cardValue);
    if (idx !== -1) removed = fromCards.splice(idx, 1)[0];
  }
  if (removed == null) return { dropId, updated:false };

  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/hands/${fromId}/cards`), fromCards),
    set(ref(db, `rooms/${state.roomCode}/deckParked`), { id: dropId, card: removed, by: fromId, at: Date.now() }),
  ]);

  if (advanceTurn) await advanceTurnFromPlayer(fromId);

  if (triggerDiscussion){
    await set(ref(db, `rooms/${state.roomCode}/discussionPopEvent`), {
      id: crypto.randomUUID(),
      by: fromId,
      at: Date.now()
    });
  }

  return { dropId, updated:true };
}

/* =========================
   ✅ ドラッグ本体
   ========================= */
function bindMyHandDrag(){
  myHandEl.addEventListener('pointerdown', (e) => {
    if (!canDragNow()) return;

    const miniEl = state.sp3Mode?.phase === 'pickDiscard' ? e.target?.closest?.('.mini-card') : null;
    const myCardEl = e.target?.closest?.('.my-card');
    let cardElInHand = myCardEl;
    let sourcePlayerId = state.userId;

    if (!cardElInHand && miniEl){
      const tag = miniEl.closest('.player-tag');
      const playerId = tag?.dataset.playerid;
      const idx = Number(miniEl.dataset.cardIndex ?? -1);
      const cards = Array.isArray(state.hands?.[playerId]?.cards) ? state.hands[playerId].cards : [];
      const cardValue = cards[idx];
      if (!playerId || idx < 0 || normalizeSp3(cardValue) === SP3_NAME) return;

      cardElInHand = document.createElement('div');
      cardElInHand.className = 'my-card as-back';
      cardElInHand.textContent = cardValue;
      cardElInHand.style.position = 'fixed';
      const r = miniEl.getBoundingClientRect();
      cardElInHand.style.left = `${r.left}px`;
      cardElInHand.style.top = `${r.top}px`;
      document.body.appendChild(cardElInHand);
      sourcePlayerId = playerId;
    }

    if (!cardElInHand) return;

    const sourceCards = Array.isArray(state.hands?.[sourcePlayerId]?.cards) ? state.hands[sourcePlayerId].cards : [];
    const cardValue = myCardEl ? cardElInHand.textContent : (sourceCards[Number(miniEl.dataset.cardIndex ?? -1)]);

    if (state.sp3Mode?.phase === 'pickDiscard' && normalizeSp3(cardValue) === SP3_NAME) return;

    let fromIndex = 0;
    let ph = document.createElement('div');
    ph.className = 'drag-placeholder';

    if (myCardEl){
      const myCardEls = Array.from(myHandEl.querySelectorAll('.my-card'));
      const domIndex = myCardEls.indexOf(cardElInHand);
      fromIndex = clamp(domIndex, 0, Math.max(0, sourceCards.length-1));
      cardElInHand.insertAdjacentElement('beforebegin', ph);
    } else {
      fromIndex = Number(miniEl.dataset.cardIndex ?? 0);
      document.body.appendChild(ph);
      ph.style.display = 'none';
    }

    const stable = computeStableGrabOffsets(cardElInHand, e.clientX, e.clientY);
    const offsetX = stable.offsetX;
    const offsetY = stable.offsetY;

    const dragEl = cardElInHand;
    document.body.appendChild(dragEl);
    dragEl.classList.add('dragging');
    dragEl.classList.remove('fx-hold');
    dragEl.style.width = `${stable.baseW}px`;
    dragEl.style.height = `${stable.baseH}px`;
    dragEl.style.visibility = 'visible';

    state.pendingOutgoing = {
      value: cardValue,
      fromIndex,
      toId: null,
      until: Date.now() + MOVE_ANIM_MS + MOVE_POST_PAD + 1200
    };

    setDraggingPos(dragEl, e.clientX - offsetX, e.clientY - offsetY);

    drag = {
      pointerId: e.pointerId,
      dragEl,
      placeholder: ph,
      offsetX, offsetY,
      cardValue,
      fromIndex,
      sourcePlayerId,
      isTempSource: !myCardEl
    };

    e.preventDefault();
  });

  window.addEventListener('pointermove', (e) => {
    if (!drag) return;
    if (e.pointerId !== drag.pointerId) return;
    setDraggingPos(drag.dragEl, e.clientX - drag.offsetX, e.clientY - drag.offsetY);
  }, { passive:true });

  window.addEventListener('pointerup', async (e) => {
    if (!drag) return;
    if (e.pointerId !== drag.pointerId) return;

    const { dragEl, placeholder, cardValue, fromIndex, offsetX, offsetY, sourcePlayerId, isTempSource } = drag;
    drag = null;

    let target = null;
    if (state.sp3Mode?.phase === 'pickDiscard'){
      const r = myHandEl.getBoundingClientRect();
      const c = rectCenter(r);
      const inside = e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom;
      if (inside) target = { type:'sp3hand', centerClient:c, playerId:state.userId };
    } else if (state.sp3Mode?.phase === 'sendDeck'){
      target = getDropTargetForDeck(e.clientX, e.clientY);
    } else if (isLastTurnPlayer(state.userId)){
      target = getDropTargetForDeck(e.clientX, e.clientY);
    } else {
      target = getDropTargetForNextPlayer(e.clientX, e.clientY);
    }

    if (!target){
      try{
        dragEl.classList.remove('dragging','as-back','fx-hold','sp3-pulse');
        dragEl.style.pointerEvents = '';
        dragEl.style.transform = '';
        dragEl.style.width = '';
        dragEl.style.height = '';
        if (!isTempSource) placeholder.replaceWith(dragEl);
        else dragEl.remove();
      }catch{
        try{ dragEl.remove(); }catch{}
      }
      state.pendingOutgoing = null;
      placeholder?.remove?.();
      renderHands();
      requestAnimationFrame(() => resolveTransits());
      return;
    }

    placeholder.remove();
    dragEl.classList.add('as-back');

    const fromLeft = e.clientX - offsetX;
    const fromTop  = e.clientY - offsetY;

    const { anim, endScale, rot1 } = animateDraggedCardToTarget(
      dragEl,
      fromLeft,
      fromTop,
      target.centerClient,
      {
        duration: MOVE_ANIM_MS,
        endScale: 0.70,
        rotateFrom: -8,
        rotateTo: (target.type === 'deck') ? 22 : 14
      }
    );

    anim.onfinish = () => {
      const p = toMainXY(target.centerClient.x, target.centerClient.y);

      try{
        dragEl.classList.remove('dragging');
        dragEl.classList.add('fx-hold','holding');
        dragEl.style.pointerEvents = 'none';

        fxLayer.appendChild(dragEl);

        dragEl.style.position = 'absolute';
        dragEl.style.left = '0px';
        dragEl.style.top  = '0px';
        dragEl.style.width = '60px';
        dragEl.style.height = '90px';
        dragEl.style.transform = `translate(${(p.x - 30)}px, ${(p.y - 45)}px) rotate(${rot1}deg) scale(${endScale})`;
      }catch{}
    };

    if (target.type === 'deck'){
      const deckOpts = state.sp3Mode?.phase === 'sendDeck'
        ? { advanceTurn:false, triggerDiscussion:false }
        : undefined;
      const res = await moveCardToDeck(sourcePlayerId, cardValue, fromIndex, deckOpts);
      registerTransit(`selfdeck:${res.dropId}`, dragEl, '__deck__', 0, 900);

      if (state.sp3Mode?.phase === 'sendDeck'){
        clearSp3Hints();
        state.sp3Mode = null;
        await advanceTurnFromPlayer(state.userId);
      }
    } else if (target.type === 'sp3hand'){
      const beforeToCount = handCount(state.userId);
      const result = await moveCardToPlayer(sourcePlayerId, state.userId, cardValue, fromIndex, { advanceTurn:false });
      const expectedToCount = Math.max(beforeToCount + 1, result?.expectedToCount ?? (beforeToCount + 1));
      registerTransit(`sp3:${result.moveId}:${state.userId}`, dragEl, state.userId, expectedToCount, 2600);
      startSp3Phase2();
    } else {
      const beforeToCount = handCount(target.playerId);
      const moveOpts = normalizeSp3(cardValue) === SP3_NAME ? { advanceTurn:false } : undefined;
      const result = await moveCardToPlayer(state.userId, target.playerId, cardValue, fromIndex, moveOpts);
      const expectedToCount = Math.max(beforeToCount + 1, result?.expectedToCount ?? (beforeToCount + 1));
      registerTransit(`selfmove:${result.moveId}:${target.playerId}`, dragEl, target.playerId, expectedToCount, 2600);

      if (normalizeSp3(cardValue) === SP3_NAME) startSp3Phase1();
    }

    state.pendingOutgoing = null;

    renderHands();
    requestAnimationFrame(() => resolveTransits());
  }, { passive:false });

  window.addEventListener('pointercancel', (e) => {
    if (!drag) return;
    if (e.pointerId !== drag.pointerId) return;

    const { dragEl, placeholder, isTempSource } = drag;
    drag = null;

    try{
      dragEl.classList.remove('dragging','as-back','fx-hold','sp3-pulse');
      dragEl.style.pointerEvents = '';
      dragEl.style.transform = '';
      dragEl.style.width = '';
      dragEl.style.height = '';
      if (!isTempSource) placeholder.replaceWith(dragEl);
      else dragEl.remove();
    }catch{
      try{ dragEl.remove(); }catch{}
    }
    state.pendingOutgoing = null;
    placeholder?.remove?.();
    renderHands();
    requestAnimationFrame(() => resolveTransits());
  });
}

/* =========================
   ★ host pop（元のまま）
   ========================= */
hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

let starting = false;
btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  if (starting) return;
  starting = true;

  try{
    btnGameStart.disabled = true;
    btnResetRoom.disabled = true;

    await Promise.all([
      remove(ref(db, `rooms/${state.roomCode}/activeTurn`)),
      remove(ref(db, `rooms/${state.roomCode}/turnDrawnTurnId`)),
      remove(ref(db, `rooms/${state.roomCode}/starterExtraGiven`)),
      remove(ref(db, `rooms/${state.roomCode}/deckParked`)),
    ]);

    state.turnDrawnTurnId = null;
    state.drawingTurnId = null;
    lastTurnId = null;

    state.pendingOutgoing = null;
    state.sp3Mode = null;
    clearSp3Hints();

    for (const [,t] of state.inTransit.entries()){
      try{ t.el.remove(); }catch{}
    }
    state.inTransit.clear();

    await resetHandsEverywhere();
    await wait(650);

    await reviveDeckUnshuffled();
    await wait(600);

    const deckSnap = await get(ref(db, `rooms/${state.roomCode}/deckRemaining`));
    const deckNow = deckSnap.val() || [];
    const hasButler = Array.isArray(deckNow) && deckNow.includes("執事");
    if (hasButler){
      const butlerId = crypto.randomUUID();
      await set(ref(db, `rooms/${state.roomCode}/butlerEvent`), {
        id: butlerId,
        by: state.userId,
        at: Date.now()
      });

      await wait(BUTLER_TOTAL_MS + BUTLER_POST_GAP_MS + 40);
    }

    const shuffleId = crypto.randomUUID();
    const times = 3;
    await set(ref(db, `rooms/${state.roomCode}/shuffleEvent`), {
      id: shuffleId,
      times,
      by: state.userId,
      at: Date.now()
    });

    await wait(shuffleTotalMs(times) + 40);

    await shuffleDeckInDB();
    await wait(600);

    await pickRandomStarterAndSetTurn();

    startPop.classList.add('hidden');
  } finally {
    btnGameStart.disabled = false;
    btnResetRoom.disabled = false;
    starting = false;
  }
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/deckGenerated`)),
    remove(ref(db, `${base}/deckRemaining`)),
    remove(ref(db, `${base}/starterPlayerId`)),
    remove(ref(db, `${base}/starterExtraGiven`)),
    remove(ref(db, `${base}/shuffleEvent`)),
    remove(ref(db, `${base}/butlerEvent`)),
    remove(ref(db, `${base}/activeTurn`)),
    remove(ref(db, `${base}/drawEvent`)),
    remove(ref(db, `${base}/moveEvent`)),
    remove(ref(db, `${base}/deckDropEvent`)),
    remove(ref(db, `${base}/deckParked`)),
    remove(ref(db, `${base}/handsResetEvent`)),
    remove(ref(db, `${base}/turnDrawnTurnId`)),
    remove(ref(db, `${base}/discussionPopEvent`)), /* ✅ 追加 */
  ]);

  const keep = document.getElementById('butlerKeepLayer');
  if (keep) keep.remove();

  fxLayer.querySelectorAll('.shuffle-overlay').forEach(el => el.remove());

  state.pendingOutgoing = null;

  for (const [,t] of state.inTransit.entries()){
    try{ t.el.remove(); }catch{}
  }
  state.inTransit.clear();

  clearLocalHandVisuals();

  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();
});

/* =========================
   ★ init
   ========================= */
function updateDeckVisibilityInit(){ updateDeckVisibility(); }
updateDeckVisibilityInit();
bindMyHandDrag();

/* ✅ mainスクロール/リサイズで横向きカード位置を再計算 */
mainEl.addEventListener('scroll', () => {
  if (state.deckParked) renderDeckParked();
}, { passive:true });
window.addEventListener('resize', () => {
  if (state.deckParked) renderDeckParked();
});
</script>
</body>
</html>
